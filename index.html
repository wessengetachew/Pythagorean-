<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Polar vs Cartesian Â· Gap Analysis</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=IM+Fell+English:ital@0;1&family=JetBrains+Mono:wght@300;400;700&display=swap');

:root {
  --pink: #ff3db4;
  --gold: #ffd700;
  --bg: #060608;
  --surface: rgba(255,255,255,0.03);
  --border: rgba(255,61,180,0.22);
  --gold-border: rgba(255,215,0,0.22);
  --green: #22c55e;
}

* { margin:0; padding:0; box-sizing:border-box; }

body {
  background: var(--bg);
  color: #d8f0d8;
  font-family: 'JetBrains Mono', monospace;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 28px 16px 80px;
  overflow-x: hidden;
}

h1 {
  font-family: 'IM Fell English', serif;
  font-size: clamp(1.7rem, 5.5vw, 3rem);
  color: var(--pink);
  text-shadow: 0 0 28px rgba(255,61,180,.65), 0 0 70px rgba(255,61,180,.25);
  letter-spacing: .05em;
  margin-bottom: 18px;
  text-align: center;
}

/* â”€â”€ Presets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.presets-wrap { max-width: 580px; width: 100%; margin-bottom: 16px; }
.pg-label {
  font-size:.57rem; text-transform:uppercase; letter-spacing:.18em;
  color:rgba(255,61,180,.5); margin-bottom:5px; margin-top:8px; margin-left:2px;
}
.pg-label.gold { color:rgba(255,215,0,.6); }
.presets { display:flex; flex-wrap:wrap; gap:6px; }
.preset-btn {
  font-family:'JetBrains Mono',monospace; font-size:.63rem;
  letter-spacing:.07em; text-transform:uppercase;
  padding:5px 12px; border-radius:20px; cursor:pointer;
  border:1px solid rgba(255,61,180,.25); background:rgba(255,255,255,.03);
  color:#8ab88a; transition:all .15s;
}
.preset-btn:hover { border-color:var(--pink); color:var(--pink); }
.preset-btn.active { background:var(--pink); border-color:var(--pink); color:#000; box-shadow:0 0 12px rgba(255,61,180,.45); }
.preset-btn.gap-active { background:var(--gold); border-color:var(--gold); color:#000; box-shadow:0 0 12px rgba(255,215,0,.45); }

/* â”€â”€ Sphere canvas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.sphere-wrap {
  width:100%; max-width:540px;
  display:flex; flex-direction:column; align-items:center; gap:13px;
}
#polarCanvas {
  display:block; border-radius:50%;
  box-shadow: 0 0 60px rgba(255,61,180,.12), 0 0 120px rgba(255,61,180,.04);
  cursor:grab;
}
#polarCanvas:active { cursor:grabbing; }

.formula-box {
  border:2px solid var(--gold); border-radius:8px;
  padding:9px 20px; background:rgba(255,215,0,.05);
  font-size:clamp(.75rem,2.3vw,.96rem); color:#fff;
  text-align:center; box-shadow:0 0 18px rgba(255,215,0,.18);
}
.formula-box em { color:var(--gold); font-style:normal; }
#cartCanvas { display:block; border-radius:4px; }

/* â”€â”€ Live Stats Bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.live-stats {
  width:100%; max-width:540px;
  background:rgba(255,215,0,.04); border:1px solid var(--gold-border);
  border-radius:8px; padding:8px 14px;
  display:grid; grid-template-columns:repeat(4,1fr); gap:6px 10px;
  margin-top:4px;
}
.stat-cell { display:flex; flex-direction:column; gap:2px; }
.stat-lbl { font-size:.5rem; text-transform:uppercase; letter-spacing:.12em; color:rgba(255,215,0,.45); }
.stat-val { font-size:.7rem; color:var(--gold); font-weight:700; }

/* â”€â”€ Rotation controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.rot-controls {
  display:flex; align-items:center; gap:12px;
  flex-wrap:wrap; justify-content:center; margin-top:2px;
}
.rot-hint { font-size:.62rem; color:rgba(255,61,180,.5); letter-spacing:.08em; }

/* â”€â”€ Panels â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.panels { display:flex; flex-direction:column; gap:11px; max-width:560px; width:100%; margin-top:18px; }
.panel { background:var(--surface); border:1px solid var(--border); border-radius:12px; padding:16px 18px; }
.panel.gold-panel { border-color:var(--gold-border); }
.panel-title {
  font-size:.59rem; text-transform:uppercase; letter-spacing:.18em;
  color:var(--pink); margin-bottom:13px;
  display:flex; align-items:center; gap:8px;
}
.panel-title.gold { color:var(--gold); }
.panel-title::after { content:''; flex:1; height:1px; background:var(--border); }
.panel-title.gold::after { background:var(--gold-border); }
.grid-2 { display:grid; grid-template-columns:1fr 1fr; gap:11px 20px; }
.cg { display:flex; flex-direction:column; gap:5px; }
label { font-size:.62rem; color:#88cc88; text-transform:uppercase; letter-spacing:.1em; }
input[type=range] {
  -webkit-appearance:none; width:100%; height:3px;
  background:rgba(255,61,180,.22); border-radius:2px; outline:none; cursor:pointer;
}
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance:none; width:14px; height:14px; border-radius:50%;
  background:var(--pink); box-shadow:0 0 8px rgba(255,61,180,.9); cursor:pointer;
}
.vd { font-size:.72rem; color:var(--gold); text-align:right; }

/* â”€â”€ Playback â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.pb-row { display:grid; grid-template-columns:1fr auto; gap:14px; align-items:end; }
.btn-row { display:flex; gap:9px; flex-wrap:wrap; }
button.ctrl {
  font-family:'JetBrains Mono',monospace; font-size:.7rem;
  letter-spacing:.1em; text-transform:uppercase;
  padding:8px 16px; border-radius:6px; cursor:pointer;
  transition:all .15s; border:1px solid var(--pink);
  background:transparent; color:var(--pink); white-space:nowrap;
}
button.ctrl:hover, button.ctrl.on { background:var(--pink); color:#000; box-shadow:0 0 14px rgba(255,61,180,.5); }
button.ctrl.gold-ctrl { border-color:var(--gold); color:var(--gold); }
button.ctrl.gold-ctrl:hover, button.ctrl.gold-ctrl.on { background:var(--gold); color:#000; box-shadow:0 0 14px rgba(255,215,0,.5); }
.speed-sub { font-size:.58rem; color:rgba(255,215,0,.5); margin-top:-2px; }
.qrow { display:flex; gap:6px; flex-wrap:wrap; margin-top:11px; align-items:center; }
.qlabel { font-size:.59rem; color:#88aa88; text-transform:uppercase; letter-spacing:.1em; }

/* loop toggle */
.loop-row {
  display:flex; align-items:center; gap:10px; margin-top:9px;
  padding-top:9px; border-top:1px solid rgba(255,61,180,.1);
}
.loop-check {
  -webkit-appearance:none; width:32px; height:17px; border-radius:9px;
  background:rgba(255,61,180,.15); border:1px solid rgba(255,61,180,.3);
  cursor:pointer; position:relative; transition:background .2s; flex-shrink:0;
}
.loop-check:checked { background:var(--pink); border-color:var(--pink); }
.loop-check::after {
  content:''; position:absolute; top:2px; left:2px;
  width:11px; height:11px; border-radius:50%; background:#fff;
  transition:transform .2s; box-shadow:0 1px 4px rgba(0,0,0,.4);
}
.loop-check:checked::after { transform:translateX(15px); }
.loop-lbl { font-size:.62rem; color:#88cc88; text-transform:uppercase; letter-spacing:.1em; }
.loop-state { font-size:.57rem; color:rgba(255,215,0,.45); }

/* â”€â”€ Gap Decomposition Panel â”€â”€â”€â”€â”€â”€â”€ */
.gap-panel {
  max-width:560px; width:100%; margin-top:0;
  background:var(--surface); border:1px solid var(--gold-border);
  border-radius:12px; overflow:hidden;
}
.gap-header {
  display:flex; align-items:center; justify-content:space-between;
  padding:14px 18px; cursor:pointer; user-select:none;
  border-bottom:1px solid transparent; transition:border-color .2s;
}
.gap-header.open { border-bottom-color:var(--gold-border); }
.gap-header-title {
  font-size:.59rem; text-transform:uppercase; letter-spacing:.18em; color:var(--gold);
}
.gap-chevron { font-size:.75rem; color:var(--gold); transition:transform .25s; }
.gap-chevron.open { transform:rotate(180deg); }
.gap-body { display:none; padding:16px 18px 18px; }
.gap-body.open { display:block; }

/* Gap controls grid */
.gap-ctrl-grid { display:grid; grid-template-columns:1fr 1fr; gap:10px 20px; margin-bottom:12px; }
.gap-ctrl-grid label { color:#88bb88; }
.gap-ctrl-grid input[type=range] { background:rgba(255,215,0,.18); }
.gap-ctrl-grid input[type=range]::-webkit-slider-thumb { background:var(--gold); box-shadow:0 0 8px rgba(255,215,0,.8); }
.gap-vd { font-size:.72rem; color:var(--gold); text-align:right; }

.gap-filter-row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:12px; }
.gap-filter-lbl { font-size:.57rem; color:rgba(255,215,0,.5); text-transform:uppercase; letter-spacing:.12em; }
.gap-filter-btn {
  font-family:'JetBrains Mono',monospace; font-size:.57rem; letter-spacing:.06em;
  text-transform:uppercase; padding:3px 9px; border-radius:12px; cursor:pointer;
  border:1px solid rgba(255,215,0,.25); background:transparent; color:#88aa55; transition:all .12s;
}
.gap-filter-btn:hover { border-color:var(--gold); color:var(--gold); }
.gap-filter-btn.active { background:var(--gold); color:#000; }

.gap-run-row { display:flex; gap:8px; margin-bottom:12px; flex-wrap:wrap; }

/* Status */
.gap-status {
  font-size:.62rem; color:#88cc88; min-height:1.4em;
  border-left:2px solid var(--gold); padding-left:8px;
  margin-bottom:10px; line-height:1.7;
}

/* Progress bar */
.gap-progress { height:3px; background:rgba(255,215,0,.12); border-radius:2px; margin-bottom:10px; overflow:hidden; display:none; }
.gap-progress-fill { height:100%; background:var(--gold); border-radius:2px; width:0%; transition:width .1s; }

/* Live stats grid for gap */
.gap-live-stats {
  display:grid; grid-template-columns:repeat(3,1fr); gap:6px; margin-bottom:12px;
}
.gap-stat {
  background:rgba(255,215,0,.04); border:1px solid rgba(255,215,0,.1);
  border-radius:6px; padding:6px 8px;
}
.gap-stat-lbl { font-size:.48rem; text-transform:uppercase; letter-spacing:.1em; color:rgba(255,215,0,.4); margin-bottom:2px; }
.gap-stat-val { font-size:.68rem; color:var(--gold); font-weight:700; word-break:break-all; }

/* Chart tabs */
.gap-tabs { display:flex; gap:5px; margin-bottom:10px; flex-wrap:wrap; }
.gap-tab {
  font-family:'JetBrains Mono',monospace; font-size:.57rem; letter-spacing:.06em;
  text-transform:uppercase; padding:4px 10px; border-radius:12px; cursor:pointer;
  border:1px solid rgba(255,215,0,.25); background:transparent; color:#88aa55; transition:all .12s;
}
.gap-tab:hover { border-color:var(--gold); color:var(--gold); }
.gap-tab.active { background:var(--gold); color:#000; border-color:var(--gold); }

#gapCanvas { display:block; border-radius:4px; width:100%; background:#060608; }

.gap-legend { display:flex; flex-wrap:wrap; gap:6px; margin-top:8px; }
.gap-leg { display:flex; align-items:center; gap:4px; font-size:.55rem; color:#88aa66; }
.gap-leg-sw { width:9px; height:9px; border-radius:2px; flex-shrink:0; }

/* Export row */
.export-row { display:flex; gap:8px; flex-wrap:wrap; margin-top:12px; padding-top:12px; border-top:1px solid rgba(255,215,0,.1); }

/* Gap presets inside the gap panel */
.gap-wave-presets { margin-bottom:14px; }
.gap-wave-presets .pg-label { font-size:.52rem; margin-top:0; margin-bottom:6px; color:rgba(255,215,0,.5); }
.gap-wave-row { display:flex; flex-wrap:wrap; gap:5px; }
.gap-wave-btn {
  font-family:'JetBrains Mono',monospace; font-size:.57rem; letter-spacing:.06em;
  text-transform:uppercase; padding:4px 10px; border-radius:16px; cursor:pointer;
  border:1px solid rgba(255,215,0,.2); background:rgba(255,215,0,.03);
  color:#88aa55; transition:all .15s;
}
.gap-wave-btn:hover { border-color:var(--gold); color:var(--gold); }
.gap-wave-btn.active { background:var(--gold); border-color:var(--gold); color:#000; }
.gap-wave-btn .n-badge {
  font-size:.48rem; opacity:.7; margin-left:3px;
}

/* â”€â”€ Multi-gap selector â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.gap-selector-wrap {
  margin-bottom:13px;
}
.gap-selector-label {
  font-size:.55rem; text-transform:uppercase; letter-spacing:.14em;
  color:rgba(255,215,0,.55); margin-bottom:6px;
  display:flex; align-items:center; gap:10px; flex-wrap:wrap;
}
.gap-selector-label span { opacity:.6; font-size:.5rem; }
.gap-chips { display:flex; flex-wrap:wrap; gap:5px; }
.gap-chip {
  font-family:'JetBrains Mono',monospace; font-size:.6rem;
  letter-spacing:.06em; padding:3px 9px; border-radius:14px;
  cursor:pointer; border:2px solid transparent;
  background:rgba(255,255,255,.04); color:#667766;
  transition:all .12s; position:relative; user-select:none;
}
.gap-chip:hover { color:#aaccaa; border-color:rgba(255,255,255,.15); }
.gap-chip.selected {
  color:#000 !important; font-weight:700;
  box-shadow:0 0 10px currentColor;
}
.gap-chip .chip-dot {
  display:inline-block; width:6px; height:6px; border-radius:50%;
  margin-right:4px; vertical-align:middle; background:currentColor;
}

/* â”€â”€ Thickness slider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.thick-row {
  display:flex; align-items:center; gap:12px; margin-bottom:12px;
  padding:8px 10px; background:rgba(255,215,0,.03);
  border:1px solid rgba(255,215,0,.1); border-radius:8px;
}
.thick-row label { color:#88bb88; font-size:.6rem; white-space:nowrap; flex-shrink:0; }
.thick-row input[type=range] { flex:1; background:rgba(255,215,0,.18); }
.thick-row input[type=range]::-webkit-slider-thumb { background:var(--gold); box-shadow:0 0 8px rgba(255,215,0,.8); }
.thick-val { font-size:.7rem; color:var(--gold); min-width:28px; text-align:right; }

/* â”€â”€ All-gaps stats table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.gap-table-wrap {
  margin-top:12px; overflow-x:auto;
  border:1px solid rgba(255,215,0,.15); border-radius:8px;
}
.gap-table-controls {
  display:flex; gap:8px; flex-wrap:wrap; align-items:center;
  padding:8px 12px; background:rgba(255,215,0,.03);
  border-bottom:1px solid rgba(255,215,0,.1);
}
.gap-table-controls label { font-size:.55rem; color:#88bb88; white-space:nowrap; }
.gap-table-controls select, .gap-table-controls input {
  font-family:'JetBrains Mono',monospace; font-size:.6rem;
  background:#0a0c0a; border:1px solid rgba(255,215,0,.25); color:var(--gold);
  padding:3px 6px; border-radius:4px; cursor:pointer;
}
#gdTableWrap table {
  width:100%; border-collapse:collapse; font-size:.6rem;
  font-family:'JetBrains Mono',monospace;
}
#gdTableWrap th {
  position:sticky; top:0; background:#0a0a08;
  color:rgba(255,215,0,.7); font-size:.52rem; text-transform:uppercase;
  letter-spacing:.1em; padding:5px 8px; text-align:right;
  border-bottom:1px solid rgba(255,215,0,.2); white-space:nowrap;
}
#gdTableWrap th:first-child { text-align:left; }
#gdTableWrap td {
  padding:4px 8px; text-align:right; border-bottom:1px solid rgba(255,215,0,.05);
  white-space:nowrap; color:#8aaa8a;
}
#gdTableWrap td:first-child { text-align:left; }
#gdTableWrap tr:hover td { background:rgba(255,215,0,.04); }
#gdTableWrap tr.gap-row-selected td { background:rgba(255,215,0,.06); }
#gdTableWrap td.gap-id { font-weight:700; }
#gdTableWrap { max-height:340px; overflow-y:auto; }

/* â”€â”€ Convergence dropdown table â”€â”€â”€â”€â”€ */
.conv-dropdown-wrap {
  margin-top:14px;
  border:1px solid rgba(255,215,0,.15); border-radius:8px; overflow:hidden;
}
.conv-dropdown-header {
  display:flex; align-items:center; justify-content:space-between;
  padding:9px 14px; background:rgba(255,215,0,.04); cursor:pointer;
  user-select:none;
}
.conv-dropdown-title { font-size:.57rem; text-transform:uppercase; letter-spacing:.16em; color:var(--gold); }
.conv-dropdown-chevron { font-size:.7rem; color:var(--gold); transition:transform .2s; }
.conv-dropdown-chevron.open { transform:rotate(180deg); }
.conv-dropdown-body { display:none; }
.conv-dropdown-body.open { display:block; }
.conv-table-controls {
  display:flex; gap:10px; flex-wrap:wrap; align-items:center;
  padding:8px 12px; background:rgba(255,215,0,.02);
  border-bottom:1px solid rgba(255,215,0,.08);
}
.conv-table-controls label { font-size:.55rem; color:#88bb88; white-space:nowrap; }
.conv-table-controls select, .conv-table-controls input[type=number] {
  font-family:'JetBrains Mono',monospace; font-size:.6rem;
  background:#0a0c0a; border:1px solid rgba(255,215,0,.25); color:var(--gold);
  padding:3px 6px; border-radius:4px; width:56px;
}
.conv-table-controls select { width:auto; }
#gdConvTableWrap { max-height:400px; overflow-y:auto; }
#gdConvTableWrap table { width:100%; border-collapse:collapse; font-size:.58rem; font-family:'JetBrains Mono',monospace; }
#gdConvTableWrap th {
  position:sticky; top:0; background:#0a0a08;
  color:rgba(255,215,0,.65); font-size:.5rem; text-transform:uppercase;
  letter-spacing:.1em; padding:5px 7px; text-align:right;
  border-bottom:1px solid rgba(255,215,0,.2); white-space:nowrap;
}
#gdConvTableWrap th:first-child, #gdConvTableWrap th:nth-child(2) { text-align:left; }
#gdConvTableWrap td {
  padding:3px 7px; text-align:right; border-bottom:1px solid rgba(255,215,0,.04);
  white-space:nowrap;
}
#gdConvTableWrap td:first-child, #gdConvTableWrap td:nth-child(2) { text-align:left; }
#gdConvTableWrap tr:hover td { background:rgba(255,215,0,.04); }
.conv-row-improving td { color:#88cc88; }
.conv-row-worsening td { color:#cc8888; }
.conv-row-best td { color:#ffd700 !important; font-weight:700; }
.conv-cell-product { color:#4ecdc4; }
.conv-cell-pi { color:#ff3db4; }
.conv-cell-err { color:#f97316; }
.conv-cell-logerr { color:#a855f7; }
.conv-cell-gap { color:var(--gold); font-weight:700; }

/* â”€â”€ Harmonics Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.harm-panel {
  max-width:560px; width:100%; margin-top:0;
  background:var(--surface); border:1px solid rgba(100,180,255,.2);
  border-radius:12px; overflow:hidden;
}
.harm-header {
  display:flex; align-items:center; justify-content:space-between;
  padding:13px 18px; cursor:pointer; user-select:none;
  border-bottom:1px solid transparent; transition:border-color .2s;
}
.harm-header.open { border-bottom-color:rgba(100,180,255,.2); }
.harm-header-title { font-size:.59rem; text-transform:uppercase; letter-spacing:.18em; color:#60a5fa; }
.harm-chevron { font-size:.75rem; color:#60a5fa; transition:transform .25s; }
.harm-chevron.open { transform:rotate(180deg); }
.harm-body { display:none; padding:14px 18px 18px; }
.harm-body.open { display:block; }

.harm-section-title {
  font-size:.52rem; text-transform:uppercase; letter-spacing:.14em;
  color:rgba(100,180,255,.55); margin-bottom:8px; margin-top:12px;
}
.harm-section-title:first-child { margin-top:0; }

/* Interval grid */
.harm-interval-grid {
  display:flex; flex-wrap:wrap; gap:5px; margin-bottom:10px;
}
.harm-interval-btn {
  font-family:'JetBrains Mono',monospace; font-size:.6rem;
  letter-spacing:.06em; padding:4px 10px; border-radius:14px;
  cursor:pointer; border:1px solid rgba(100,180,255,.25);
  background:rgba(100,180,255,.04); color:#60a5fa66;
  transition:all .12s;
}
.harm-interval-btn:hover { border-color:#60a5fa; color:#60a5fa; }
.harm-interval-btn.active {
  background:#60a5fa; border-color:#60a5fa; color:#000; font-weight:700;
  box-shadow:0 0 10px rgba(96,165,250,.4);
}
.harm-interval-btn .ratio-badge { font-size:.48rem; opacity:.7; margin-left:3px; }

/* Consonance color key */
.harm-consonance-key {
  display:flex; gap:8px; flex-wrap:wrap; margin-bottom:10px;
}
.harm-cons-pill {
  font-size:.53rem; padding:2px 8px; border-radius:10px;
  display:flex; align-items:center; gap:4px;
}
.harm-cons-dot { width:7px; height:7px; border-radius:50%; flex-shrink:0; }

/* Audio row */
.harm-audio-row {
  display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:10px;
}
.harm-freq-display {
  font-size:.9rem; color:#60a5fa; font-weight:700; text-align:center;
  padding:8px; background:rgba(96,165,250,.08); border:1px solid rgba(96,165,250,.2);
  border-radius:6px; letter-spacing:.05em;
}
.harm-note-display {
  font-size:.7rem; color:#a3e635; text-align:center;
  padding:8px; background:rgba(163,230,53,.06); border:1px solid rgba(163,230,53,.15);
  border-radius:6px;
}

.harm-btn-row { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px; }
.harm-btn {
  font-family:'JetBrains Mono',monospace; font-size:.65rem;
  letter-spacing:.08em; text-transform:uppercase; padding:7px 14px;
  border-radius:6px; cursor:pointer; border:1px solid rgba(96,165,250,.35);
  background:transparent; color:#60a5fa; transition:all .15s;
}
.harm-btn:hover, .harm-btn.on { background:#60a5fa; color:#000; box-shadow:0 0 12px rgba(96,165,250,.4); }

/* Harmonic mode toggle */
.harm-mode-row {
  display:flex; align-items:center; gap:10px; margin-top:8px;
  padding-top:8px; border-top:1px solid rgba(96,165,250,.1);
}
.harm-toggle {
  -webkit-appearance:none; width:32px; height:17px; border-radius:9px;
  background:rgba(96,165,250,.15); border:1px solid rgba(96,165,250,.3);
  cursor:pointer; position:relative; transition:background .2s; flex-shrink:0;
}
.harm-toggle:checked { background:#60a5fa; border-color:#60a5fa; }
.harm-toggle::after {
  content:''; position:absolute; top:2px; left:2px;
  width:11px; height:11px; border-radius:50%; background:#fff;
  transition:transform .2s; box-shadow:0 1px 4px rgba(0,0,0,.4);
}
.harm-toggle:checked::after { transform:translateX(15px); }
.harm-lbl { font-size:.62rem; color:#88cc88; text-transform:uppercase; letter-spacing:.1em; }
.harm-state { font-size:.57rem; color:rgba(96,165,250,.45); }

/* Arnold tongue mini display */
.arnold-row { display:flex; gap:10px; align-items:center; margin-bottom:8px; }
.arnold-val { font-size:.65rem; color:#e879f9; min-width:32px; text-align:right; }

</style>
</head>
<body>

<h1>Polar vs Cartesian</h1>

<!-- Preset groups -->
<div class="presets-wrap">
  <div class="pg-label">Classics</div>
  <div class="presets" id="pgClassic"></div>
  <div class="pg-label">Complex</div>
  <div class="presets" id="pgComplex"></div>
  <div class="pg-label">Organic</div>
  <div class="presets" id="pgOrganic"></div>
  <div class="pg-label">Geometric</div>
  <div class="presets" id="pgGeo"></div>
  <div class="pg-label">Ethereal</div>
  <div class="presets" id="pgEth"></div>
  <div class="pg-label gold">Gap Waves <span style="font-size:.5rem;opacity:.5">â€” run decomposition below to refine</span></div>
  <div class="presets" id="pgGapWave"></div>
</div>

<!-- Sphere + formula + cart -->
<div class="sphere-wrap">
  <canvas id="polarCanvas"></canvas>

  <div class="rot-controls">
    <span class="rot-hint">âŸ³ drag sphere to rotate</span>
    <button class="ctrl" id="btnAutoRot">âŸ³ Auto-Rotate</button>
    <button class="ctrl" id="btnResetRot" style="font-size:.63rem;padding:6px 11px">â†º Reset View</button>
  </div>

  <div class="formula-box">
    f(Î¸) = <em id="fA">1.9</em> + sin(<em id="fB">3</em>Î¸) Â· sin(<em id="fC">3</em>Î¸ / <em id="fD">32</em>)
  </div>
  <canvas id="cartCanvas"></canvas>

  <!-- Multi-gap selector â€” main sphere area, shown after compute -->
  <div id="mainGapSelector" style="display:none;width:100%;max-width:540px;margin-bottom:4px;">
    <div style="font-size:.53rem;text-transform:uppercase;letter-spacing:.16em;color:rgba(255,215,0,.55);margin-bottom:6px;display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
      <span>ğŸ¨ Highlight gap classes on sphere &amp; cart</span>
      <span style="opacity:.5;font-size:.48rem">â€” click multiple to overlay in color</span>
      <button class="gap-filter-btn" onclick="gdClearSelection()" style="margin-left:auto;font-size:.52rem">âœ• Clear all</button>
    </div>
    <div class="gap-chips" id="mainGapChips"></div>
  </div>

  <!-- Live stats always visible -->
  <div class="live-stats" id="liveStats">
    <div class="stat-cell"><div class="stat-lbl">Progress</div><div class="stat-val" id="stProg">0%</div></div>
    <div class="stat-cell"><div class="stat-lbl">Î¸ current</div><div class="stat-val" id="stTheta">0</div></div>
    <div class="stat-cell"><div class="stat-lbl">f(Î¸) current</div><div class="stat-val" id="stFTheta">â€”</div></div>
    <div class="stat-cell"><div class="stat-lbl">f(Î¸) min</div><div class="stat-val" id="stFMin">â€”</div></div>
    <div class="stat-cell"><div class="stat-lbl">f(Î¸) max</div><div class="stat-val" id="stFMax">â€”</div></div>
    <div class="stat-cell"><div class="stat-lbl">f(Î¸) mean</div><div class="stat-val" id="stFMean">â€”</div></div>
    <div class="stat-cell"><div class="stat-lbl">Pts drawn</div><div class="stat-val" id="stPts">0</div></div>
    <div class="stat-cell"><div class="stat-lbl">Î¸ total (Ã—Ï€)</div><div class="stat-val" id="stThetaMax">64</div></div>
  </div>
</div>

<!-- Panels -->
<div class="panels">

  <!-- Formula -->
  <div class="panel">
    <div class="panel-title">Formula Parameters</div>
    <div class="grid-2">
      <div class="cg"><label>A â€” offset</label><input type="range" id="sA" min="0.1" max="4" step="0.05" value="1.9"><div class="vd" id="dA">1.9</div></div>
      <div class="cg"><label>B â€” outer freq</label><input type="range" id="sB" min="1" max="12" step="0.5" value="3"><div class="vd" id="dB">3</div></div>
      <div class="cg"><label>C â€” inner freq</label><input type="range" id="sC" min="1" max="12" step="0.5" value="3"><div class="vd" id="dC">3</div></div>
      <div class="cg"><label>D â€” modulation</label><input type="range" id="sD" min="4" max="128" step="1" value="32"><div class="vd" id="dD">32</div></div>
      <div class="cg"><label>Î¸ range (Ã— Ï€)</label><input type="range" id="sTheta" min="2" max="300" step="1" value="64"><div class="vd" id="dTheta">64Ï€</div></div>
      <div class="cg"><label>Trail / History</label><input type="range" id="sTrail" min="1" max="40" step="1" value="6"><div class="vd" id="dTrail">6</div></div>
    </div>
  </div>

  <!-- Playback -->
  <div class="panel">
    <div class="panel-title">Playback &amp; Speed</div>
    <div class="pb-row">
      <div class="cg">
        <label>Draw speed</label>
        <input type="range" id="sSpeed" min="0.05" max="40" step="0.05" value="8">
        <div class="vd" id="dSpeed">8.0</div>
        <div class="speed-sub" id="speedDesc">normal</div>
      </div>
      <div class="btn-row">
        <button class="ctrl" id="btnPlay">â–¶ Play</button>
        <button class="ctrl" id="btnReset">â†º Reset</button>
        <button class="ctrl gold-ctrl" id="btnExport4K" title="Export 4K PNG of sphere">â¬‡ 4K</button>
      </div>
    </div>
    <div class="loop-row">
      <input type="checkbox" class="loop-check" id="cbLoop">
      <span class="loop-lbl">Loop</span>
      <span class="loop-state" id="loopState">off â€” stops at end</span>
    </div>
    <div class="qrow">
      <span class="qlabel">Quick:</span>
      <button class="ctrl" style="font-size:.6rem;padding:4px 9px" onclick="setSpeed(0.1)">Ultra Slow</button>
      <button class="ctrl" style="font-size:.6rem;padding:4px 9px" onclick="setSpeed(0.5)">Crawl</button>
      <button class="ctrl" style="font-size:.6rem;padding:4px 9px" onclick="setSpeed(2)">Slow</button>
      <button class="ctrl" style="font-size:.6rem;padding:4px 9px" onclick="setSpeed(8)">Normal</button>
      <button class="ctrl" style="font-size:.6rem;padding:4px 9px" onclick="setSpeed(20)">Fast</button>
      <button class="ctrl" style="font-size:.6rem;padding:4px 9px" onclick="setSpeed(40)">Max</button>
    </div>
  </div>

</div>


<!-- â•â• Harmonics Panel â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="harm-panel panels" style="margin-top:11px" id="harmPanel">
  <div class="harm-header" id="harmHeader">
    <div class="harm-header-title">â™ª Harmonic Analysis Â· Farey Intervals</div>
    <span class="harm-chevron" id="harmChevron">â–¼</span>
  </div>
  <div class="harm-body" id="harmBody">

    <!-- Harmonic sphere coloring mode -->
    <div class="harm-mode-row">
      <input type="checkbox" class="harm-toggle" id="harmColorMode">
      <span class="harm-lbl">Harmonic Color Mode</span>
      <span class="harm-state" id="harmModeState">off â€” sphere uses default colors</span>
    </div>

    <!-- Farey interval presets -->
    <div class="harm-section-title">Farey Harmonic Intervals</div>
    <div class="harm-interval-grid" id="harmIntervalGrid"></div>

    <!-- Consonance color key -->
    <div class="harm-consonance-key">
      <div class="harm-cons-pill"><div class="harm-cons-dot" style="background:#22c55e"></div><span style="color:#22c55e;font-size:.52rem">Unison (1:1)</span></div>
      <div class="harm-cons-pill"><div class="harm-cons-dot" style="background:#60a5fa"></div><span style="color:#60a5fa;font-size:.52rem">Consonant qâ‰¤4</span></div>
      <div class="harm-cons-pill"><div class="harm-cons-dot" style="background:#ffd700"></div><span style="color:#ffd700;font-size:.52rem">Moderate qâ‰¤16</span></div>
      <div class="harm-cons-pill"><div class="harm-cons-dot" style="background:#f97316"></div><span style="color:#f97316;font-size:.52rem">Complex qâ‰¤64</span></div>
      <div class="harm-cons-pill"><div class="harm-cons-dot" style="background:#a855f7"></div><span style="color:#a855f7;font-size:.52rem">Dissonant q>64</span></div>
    </div>

    <!-- Selected interval info -->
    <div class="harm-audio-row">
      <div class="harm-freq-display" id="harmFreqDisplay">â€” Hz</div>
      <div class="harm-note-display" id="harmNoteDisplay">â€” Â· â€”</div>
    </div>

    <!-- Audio controls -->
    <div class="harm-section-title">Audio</div>
    <div class="harm-btn-row">
      <button class="harm-btn" id="harmPlayBtn" onclick="harmPlay()">â–¶ Play</button>
      <button class="harm-btn" id="harmChordBtn" onclick="harmChord()">â™ª Chord</button>
      <button class="harm-btn" id="harmArpBtn" onclick="harmArp()">âˆ¿ Arpeggio</button>
      <button class="harm-btn" onclick="harmStop()">â–  Stop</button>
    </div>
    <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
      <div class="cg" style="flex:1;min-width:120px">
        <label style="font-size:.58rem;color:#88bb88">Base Hz</label>
        <input type="range" id="harmBaseHz" min="110" max="880" step="1" value="220" style="background:rgba(96,165,250,.2)">
        <div class="vd" id="harmBaseHzVal" style="color:#60a5fa">220 Hz</div>
      </div>
      <div class="cg" style="flex:1;min-width:100px">
        <label style="font-size:.58rem;color:#88bb88">Volume</label>
        <input type="range" id="harmVol" min="0" max="1" step="0.05" value="0.35" style="background:rgba(96,165,250,.2)">
        <div class="vd" id="harmVolVal" style="color:#60a5fa">35%</div>
      </div>
      <div class="cg" style="flex:1;min-width:100px">
        <label style="font-size:.58rem;color:#88bb88">Waveform</label>
        <select id="harmWave" style="font-family:'JetBrains Mono',monospace;font-size:.62rem;background:#0a0c0a;border:1px solid rgba(96,165,250,.25);color:#60a5fa;padding:4px 6px;border-radius:4px;width:100%">
          <option value="sine">Sine</option>
          <option value="triangle">Triangle</option>
          <option value="square">Square</option>
          <option value="sawtooth">Sawtooth</option>
        </select>
      </div>
    </div>

    <!-- Arnold Tongue K parameter -->
    <div class="harm-section-title">Arnold Tongue Â· Sphere Warp</div>
    <div class="arnold-row">
      <label style="font-size:.58rem;color:#88bb88;flex-shrink:0">K coupling</label>
      <input type="range" id="harmArnold" min="0" max="2" step="0.01" value="0" style="flex:1;background:rgba(232,121,249,.2)">
      <span class="arnold-val" id="harmArnoldVal">0.00</span>
      <button class="harm-btn" style="font-size:.55rem;padding:4px 8px" onclick="applyArnoldWarp()">Apply</button>
      <button class="harm-btn" style="font-size:.55rem;padding:4px 8px" onclick="resetArnold()">Reset</button>
    </div>
    <div style="font-size:.52rem;color:rgba(96,165,250,.4);margin-top:-4px">
      Warp sphere with KÂ·sin(2Ï€Â·f(Î¸)) perturbation from Arnold circle map
    </div>

  </div>
</div>

<!-- â•â• Gap Decomposition Panel â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="gap-panel panels" style="margin-top:11px">
  <div class="gap-header" id="gapHeader">
    <div class="gap-header-title">âš¡ Gap Decomposition &amp; Î¶(s) Analysis</div>
    <span class="gap-chevron" id="gapChevron">â–¼</span>
  </div>
  <div class="gap-body" id="gapBody">

    <!-- Controls -->
    <div class="gap-ctrl-grid">
      <div class="cg">
        <label>Max N (primes up to)</label>
        <input type="range" id="gdN" min="100000" max="300000000" step="100000" value="10000000">
        <div class="gap-vd" id="gdND">10,000,000</div>
      </div>
      <div class="cg">
        <label>Î¶ exponent s</label>
        <input type="range" id="gdS" min="1.01" max="10" step="0.01" value="2">
        <div class="gap-vd" id="gdSD" style="color:var(--gold)">s = 2.00</div>
      </div>
    </div>

    <div class="gap-filter-row">
      <span class="gap-filter-lbl">Gap filter:</span>
      <button class="gap-filter-btn active" data-filter="all" onclick="setGapFilter(this,'all')">All</button>
      <button class="gap-filter-btn" data-filter="tiny" onclick="setGapFilter(this,'tiny')">2â€“10</button>
      <button class="gap-filter-btn" data-filter="small" onclick="setGapFilter(this,'small')">2â€“30</button>
      <button class="gap-filter-btn" data-filter="medium" onclick="setGapFilter(this,'medium')">20â€“80</button>
      <button class="gap-filter-btn" data-filter="large" onclick="setGapFilter(this,'large')">50â€“200</button>
    </div>

    <div class="gap-run-row">
      <button class="ctrl gold-ctrl" id="gdRunBtn" onclick="gdRun()">â–¶ Compute</button>
      <button class="ctrl gold-ctrl" onclick="gdClear()" style="font-size:.63rem;padding:6px 11px">âœ• Clear</button>
      <button class="ctrl gold-ctrl" id="gdExportPNG" onclick="gdExport4K()" style="display:none">â¬‡ 4K PNG</button>
      <button class="ctrl gold-ctrl" id="gdExportCSV" onclick="gdExportCSV()" style="display:none">â¬‡ Full CSV</button>
      <button class="ctrl gold-ctrl" id="gdExportTXT" onclick="gdExportTXT()" style="display:none">â¬‡ Report TXT</button>
    </div>

    <!-- Thickness & gap multi-selector (always visible for viz panel) -->
    <div class="thick-row">
      <label>Trace Thickness</label>
      <input type="range" id="gdThick" min="0.5" max="8" step="0.5" value="1.35">
      <span class="thick-val" id="gdThickVal">1.35px</span>
    </div>

    <!-- Multi-gap color selector â€” populated after compute -->
    <div class="gap-selector-wrap" id="gdSelectorWrap" style="display:none">
      <div class="gap-selector-label">
        Click gaps to highlight on sphere &amp; cart
        <span>â€” each gets its own color; deselect to remove</span>
        <button class="gap-filter-btn" onclick="gdClearSelection()" style="margin-left:auto">âœ• Clear all</button>
      </div>
      <div class="gap-chips" id="gdChips"></div>
    </div>

    <div class="gap-progress" id="gdProgress"><div class="gap-progress-fill" id="gdProgressFill"></div></div>
    <div class="gap-status" id="gdStatus">Run decomposition to analyze prime gap contributions to Î¶(s). Default: 10M primes.</div>

    <!-- Live stats -->
    <div class="gap-live-stats" id="gdStatsGrid" style="display:none">
      <div class="gap-stat"><div class="gap-stat-lbl">Total primes</div><div class="gap-stat-val" id="gst0">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Gap families</div><div class="gap-stat-val" id="gst1">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Max gap</div><div class="gap-stat-val" id="gst2">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Target Î¶(s)</div><div class="gap-stat-val" id="gst3">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Computed product</div><div class="gap-stat-val" id="gst4">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Rel. error</div><div class="gap-stat-val" id="gst5">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Twin primes (g=2)</div><div class="gap-stat-val" id="gst6">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Cousin primes (g=4)</div><div class="gap-stat-val" id="gst7">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Sexy primes (g=6)</div><div class="gap-stat-val" id="gst8">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Most common gap</div><div class="gap-stat-val" id="gst9">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Twin ratio (g2/g4)</div><div class="gap-stat-val" id="gst10">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Calculated Ï€</div><div class="gap-stat-val" id="gst11">â€”</div></div>
    </div>


    <!-- Chart tabs -->
    <div class="gap-tabs" id="gdTabs" style="display:none">
      <button class="gap-tab active" onclick="gdSwitchTab(this,'contrib')">Contributions</button>
      <button class="gap-tab" onclick="gdSwitchTab(this,'dist')">Distribution</button>
      <button class="gap-tab" onclick="gdSwitchTab(this,'conv')">Convergence</button>
      <button class="gap-tab" onclick="gdSwitchTab(this,'ratio')">Gap Ratios</button>
      <button class="gap-tab" onclick="gdSwitchTab(this,'pct')">% Share</button>
    </div>

    <canvas id="gapCanvas" height="300"></canvas>
    <div class="gap-legend" id="gdLegend"></div>

    <!-- All-gaps stats table -->
    <div class="gap-table-wrap" id="gdTableSection" style="display:none">
      <div class="gap-table-controls">
        <label>Sort by:
          <select id="gdTableSort" onchange="gdBuildTable()">
            <option value="gap">Gap â†‘</option>
            <option value="count_desc">Count â†“</option>
            <option value="logshare_desc">Log-Î¶ share â†“</option>
            <option value="product_desc">Product â†“</option>
            <option value="cumulative">Cumulative â†‘</option>
          </select>
        </label>
        <label>Decimals:
          <input type="number" id="gdTableDec" min="2" max="20" value="8" style="width:46px" onchange="gdBuildTable()">
        </label>
        <label>Show top:
          <select id="gdTableTop" onchange="gdBuildTable()">
            <option value="0">All</option>
            <option value="10">10</option>
            <option value="25">25</option>
            <option value="50">50</option>
            <option value="100">100</option>
          </select>
        </label>
        <label><input type="checkbox" id="gdTableHighlight" checked onchange="gdBuildTable()"> Highlight selected</label>
      </div>
      <div id="gdTableWrap"></div>
    </div>

    <!-- Convergence to Ï€Â²/6 dropdown table -->
    <div class="conv-dropdown-wrap" id="gdConvSection" style="display:none">
      <div class="conv-dropdown-header" id="convDropHeader">
        <div class="conv-dropdown-title">âŸ¶ Step-by-step convergence to Ï€Â²/6 = Î¶(2)</div>
        <span class="conv-dropdown-chevron" id="convDropChev">â–¼</span>
      </div>
      <div class="conv-dropdown-body" id="convDropBody">
        <div class="conv-table-controls">
          <label>Sort:
            <select id="convSort" onchange="gdBuildConvTable()">
              <option value="gap_asc">Gap â†‘ (natural order)</option>
              <option value="logshare_desc">Log-share â†“</option>
              <option value="cumulative_asc">Cumulative product â†‘</option>
              <option value="relerr_asc">Rel. error â†‘ (best first)</option>
            </select>
          </label>
          <label>Decimals:
            <input type="number" id="convDec" min="2" max="20" value="12" onchange="gdBuildConvTable()">
          </label>
          <label>Show top:
            <select id="convTop" onchange="gdBuildConvTable()">
              <option value="0">All steps</option>
              <option value="10">10</option>
              <option value="25">25</option>
              <option value="50">50</option>
            </select>
          </label>
          <label><input type="checkbox" id="convShowPi" checked onchange="gdBuildConvTable()"> Show Ï€ estimate</label>
          <label><input type="checkbox" id="convShowLog" checked onchange="gdBuildConvTable()"> logâ‚â‚€ error</label>
          <label><input type="checkbox" id="convShowDelta" checked onchange="gdBuildConvTable()"> Î” product</label>
        </div>
        <div id="gdConvTableWrap"></div>
      </div>
    </div>

  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PRESETS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const PRESET_GROUPS = {
  pgClassic: [
    { name:'Original',   A:1.9, B:3,  C:3,  D:32,  theta:64,  trail:6  },
    { name:'Halo',       A:2,   B:1,  C:1,  D:128, theta:4,   trail:1  },
    { name:'Daisy',      A:1.0, B:5,  C:5,  D:20,  theta:40,  trail:6  },
    { name:'Sunflower',  A:1.0, B:5,  C:5,  D:21,  theta:42,  trail:5  },
    { name:'Rose',       A:2.0, B:4,  C:4,  D:16,  theta:32,  trail:6  },
    { name:'Lily',       A:1.5, B:6,  C:6,  D:18,  theta:36,  trail:6  },
  ],
  pgComplex: [
    { name:'Hypnotic',   A:0.5, B:7,  C:7,  D:16,  theta:64,  trail:8  },
    { name:'Galaxy',     A:1.5, B:9,  C:1,  D:64,  theta:128, trail:4  },
    { name:'Fractal',    A:0.8, B:11, C:11, D:43,  theta:86,  trail:8  },
    { name:'Mandala',    A:1.2, B:8,  C:8,  D:40,  theta:80,  trail:6  },
    { name:'Deep Space', A:0.6, B:12, C:3,  D:96,  theta:128, trail:3  },
    { name:'Cosmos',     A:1.0, B:10, C:2,  D:80,  theta:128, trail:4  },
    { name:'Nebula',     A:1.3, B:9,  C:4,  D:72,  theta:108, trail:5  },
    { name:'Quasar',     A:0.7, B:11, C:7,  D:55,  theta:110, trail:3  },
  ],
  pgOrganic: [
    { name:'Butterfly',  A:2.0, B:2,  C:4,  D:8,   theta:32,  trail:10 },
    { name:'Jellyfish',  A:1.8, B:3,  C:2,  D:12,  theta:48,  trail:8  },
    { name:'Fern',       A:1.1, B:2,  C:5,  D:10,  theta:40,  trail:7  },
    { name:'Coral',      A:1.4, B:4,  C:2,  D:28,  theta:56,  trail:6  },
    { name:'Anemone',    A:1.6, B:5,  C:3,  D:15,  theta:60,  trail:6  },
    { name:'Seashell',   A:2.2, B:3,  C:1,  D:24,  theta:48,  trail:5  },
    { name:'Vine',       A:1.0, B:3,  C:7,  D:14,  theta:56,  trail:6  },
    { name:'Mycelium',   A:0.9, B:6,  C:2,  D:36,  theta:72,  trail:4  },
  ],
  pgGeo: [
    { name:'Crystal',    A:2.5, B:4,  C:4,  D:24,  theta:48,  trail:6  },
    { name:'Spiral',     A:1.2, B:1,  C:6,  D:12,  theta:96,  trail:5  },
    { name:'Hexagon',    A:2.0, B:6,  C:6,  D:36,  theta:72,  trail:6  },
    { name:'Star-12',    A:1.8, B:12, C:12, D:48,  theta:96,  trail:7  },
    { name:'Diamond',    A:2.1, B:4,  C:8,  D:20,  theta:40,  trail:6  },
    { name:'Pinwheel',   A:1.3, B:3,  C:9,  D:18,  theta:54,  trail:6  },
    { name:'Web',        A:0.9, B:7,  C:3,  D:42,  theta:84,  trail:5  },
    { name:'Lattice',    A:1.7, B:5,  C:7,  D:35,  theta:70,  trail:5  },
  ],
  pgEth: [
    { name:'Whisper',    A:3.5, B:2,  C:1,  D:16,  theta:8,   trail:2  },
    { name:'Phantom',    A:0.3, B:8,  C:8,  D:32,  theta:64,  trail:2  },
    { name:'Aurora',     A:1.9, B:4,  C:1,  D:48,  theta:96,  trail:3  },
    { name:'Mirage',     A:2.3, B:5,  C:2,  D:30,  theta:60,  trail:4  },
    { name:'Specter',    A:1.5, B:7,  C:2,  D:56,  theta:112, trail:2  },
    { name:'Wraith',     A:0.5, B:10, C:5,  D:100, theta:100, trail:1  },
    { name:'Solstice',   A:2.8, B:3,  C:3,  D:64,  theta:64,  trail:5  },
    { name:'Eclipse',    A:1.9, B:2,  C:6,  D:12,  theta:24,  trail:3  },
  ],
  pgGapWave: [], // populated dynamically from decomposition data
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAP COLOR PALETTE (shared everywhere)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const GAP_PALETTE = {
  2:'#ffd700', 4:'#4ecdc4', 6:'#a855f7', 8:'#f97316',
  10:'#22c55e', 12:'#38bdf8', 14:'#fb7185', 18:'#e879f9',
  24:'#facc15', 30:'#34d399', 36:'#60a5fa', 42:'#f87171',
  48:'#a3e635', 72:'#fb923c', 86:'#c084fc',
};
const FALLBACK_COLORS = [
  '#ffd700','#4ecdc4','#a855f7','#f97316','#22c55e','#38bdf8',
  '#fb7185','#e879f9','#facc15','#34d399','#60a5fa','#f87171',
  '#a3e635','#fb923c','#c084fc','#ff6b9d','#00d2ff','#7fff00',
];
function gapColor(g, idx){ return GAP_PALETTE[g] || FALLBACK_COLORS[idx % FALLBACK_COLORS.length]; }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MULTI-GAP SELECTION STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Map: gapValue â†’ color string (when selected)
let selectedGaps = new Map();
// Lookup: gapValue â†’ index in allGaps array (for color assignment)
let gapIndexMap = {};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  VISUALIZATION STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let A=1.9, B=3, C=3, D=32, thetaTotal=64*Math.PI, trailFade=6;
let speed=8, paused=true, looping=false;
let traceThickness = 1.35;

const TOTAL_PTS = 8000;
let precomputed = [];
let drawProgress = 0;
let lastCartProg = 0;

// Precomputed stats
let fMin=Infinity, fMax=-Infinity, fSum=0;

// 3D rotation
let rotMat = [1,0,0, 0,1,0, 0,0,1];
let autoRotate = false;
let isDrag=false, lastMX=0, lastMY=0;

const PAD = {l:38,r:14,t:12,b:26};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CANVASES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const pCv = document.getElementById('polarCanvas');
const pCtx = pCv.getContext('2d');
const cCv = document.getElementById('cartCanvas');
const cCtx = cCv.getContext('2d');
let cBuf;

function setSize() {
  const w = Math.min(window.innerWidth - 40, 520);
  pCv.width = pCv.height = w;
  cCv.width = w; cCv.height = Math.round(w * 0.38);
}
setSize();
window.addEventListener('resize', () => { setSize(); hardReset(); });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  3D MATH
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function mmul(a, b) {
  return [
    a[0]*b[0]+a[1]*b[3]+a[2]*b[6], a[0]*b[1]+a[1]*b[4]+a[2]*b[7], a[0]*b[2]+a[1]*b[5]+a[2]*b[8],
    a[3]*b[0]+a[4]*b[3]+a[5]*b[6], a[3]*b[1]+a[4]*b[4]+a[5]*b[7], a[3]*b[2]+a[4]*b[5]+a[5]*b[8],
    a[6]*b[0]+a[7]*b[3]+a[8]*b[6], a[6]*b[1]+a[7]*b[4]+a[8]*b[7], a[6]*b[2]+a[7]*b[5]+a[8]*b[8]
  ];
}
function mrotX(a) { const c=Math.cos(a),s=Math.sin(a); return [1,0,0, 0,c,-s, 0,s,c]; }
function mrotY(a) { const c=Math.cos(a),s=Math.sin(a); return [c,0,s, 0,1,0, -s,0,c]; }
function applyM(m, x, y, z) {
  return [m[0]*x+m[1]*y+m[2]*z, m[3]*x+m[4]*y+m[5]*z, m[6]*x+m[7]*y+m[8]*z];
}
function proj(rx, ry, rz) {
  const fov = 2.8, scale = fov / (fov - rz);
  const R = pCv.width * 0.37;
  return [pCv.width/2 + rx*R*scale, pCv.height/2 - ry*R*scale];
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FORMULA & SPHERE MAPPING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function f(t) { return A + Math.sin(B*t) * Math.sin(C*t/D); }

function toSphere(t, r) {
  const lon = t;
  const polar = (t / thetaTotal) * Math.PI;
  const rn = r / (A + 1.2);
  const x = rn * Math.sin(polar) * Math.cos(lon);
  const y = rn * Math.cos(polar);
  const z = rn * Math.sin(polar) * Math.sin(lon);
  return [x, y, z];
}

function updateFormula() {
  document.getElementById('fA').textContent = A;
  document.getElementById('fB').textContent = B;
  document.getElementById('fC').textContent = C;
  document.getElementById('fD').textContent = D;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PRECOMPUTE â€” now stores gap-class identity per point
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function precompute() {
  precomputed = new Array(TOTAL_PTS);
  fMin=Infinity; fMax=-Infinity; fSum=0;

  // Build a fast lookup: for each point index â†’ which gap class does it visually correspond to
  // We derive this from the gdData if available: primes falling inside [t, t+dt] map to gap families.
  // For the sphere rendering, gap assignment is computed from visualization parameters (B, C, D)
  // We use a simpler approach: tag each point by the nearest gap class from gapFamilies if data exists.
  // Without data, gap = null (no coloring).
  let gapAtPoint = null;
  if (gdData) {
    gapAtPoint = buildGapAtPoint();
  }

  for (let i = 0; i < TOTAL_PTS; i++) {
    const t = (i / TOTAL_PTS) * thetaTotal;
    const r = f(t);
    if (r < fMin) fMin = r;
    if (r > fMax) fMax = r;
    fSum += r;
    const [x,y,z] = harmArnoldK > 0 ? toSphereWarped(t, r) : toSphere(t, r);
    const hue = harmColorMode
      ? null  // will be set to harmonic color below
      : 295 + (i/TOTAL_PTS)*40;
    const gap = gapAtPoint ? gapAtPoint[i] : null;
    const harmCol = harmColorMode ? harmColorForProgress(i/TOTAL_PTS) : null;
    precomputed[i] = [x, y, z, hue, gap, harmCol];
  }
  document.getElementById('stFMin').textContent = fMin.toFixed(4);
  document.getElementById('stFMax').textContent = fMax.toFixed(4);
  document.getElementById('stFMean').textContent = (fSum/TOTAL_PTS).toFixed(4);
  document.getElementById('stThetaMax').textContent = Math.round(thetaTotal/Math.PI);
}

// Map each point index to a gap class by finding which prime gap the Î¸ value falls within.
// Î¸ at point i â†’ t = (i/TOTAL_PTS)*thetaTotal. We scale t into [0, maxPrime] range and find
// the surrounding prime pair. The gap between that prime pair gives the gap class.
function buildGapAtPoint() {
  const { primes, gapFamilies } = gdData;
  if (!primes || primes.length < 2) return null;
  const maxP = primes[primes.length-1];

  // Build sorted list of [prime, gap] pairs for binary search
  // gap[i] = primes[i+1] - primes[i], associated with primes[i]
  const pArr = primes; // already sorted
  const result = new Array(TOTAL_PTS).fill(null);

  for (let i = 0; i < TOTAL_PTS; i++) {
    const t = (i / TOTAL_PTS) * thetaTotal;
    // Map t (0..thetaTotal) â†’ prime index using t/thetaTotal * primes.length
    const pIdx = Math.min(pArr.length - 2, Math.floor((t / thetaTotal) * (pArr.length - 1)));
    if (pIdx >= 0 && pIdx < pArr.length - 1) {
      result[i] = pArr[pIdx+1] - pArr[pIdx];
    }
  }
  return result;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CARTESIAN BUFFER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function makeCartBuf() {
  cBuf = document.createElement('canvas');
  cBuf.width = cCv.width; cBuf.height = cCv.height;
  drawCartGrid(cBuf.getContext('2d'));
  lastCartProg = 0;
}

function drawCartGrid(ctx) {
  const w=ctx.canvas.width, h=ctx.canvas.height;
  const {l,r:pr,t,b}=PAD, pw=w-l-pr, ph=h-t-b;
  const yMax=Math.ceil(A+1.2);
  ctx.fillStyle='#060608'; ctx.fillRect(0,0,w,h);
  ctx.font=`${Math.max(8,w*.021)}px JetBrains Mono,monospace`;
  for(let yv=0;yv<=yMax;yv++){
    const py=h-b-(yv/yMax)*ph;
    ctx.strokeStyle='#182018'; ctx.lineWidth=0.7;
    ctx.beginPath(); ctx.moveTo(l,py); ctx.lineTo(w-pr,py); ctx.stroke();
    ctx.fillStyle='#3a7040'; ctx.textAlign='right'; ctx.textBaseline='middle';
    ctx.fillText(yv,l-5,py);
  }
  const tmPi=Math.round(thetaTotal/Math.PI);
  [4,8,16,32,48,64,96,128,160,192,240,300].filter(v=>v<=tmPi).forEach(tv=>{
    const px=l+(tv/tmPi)*pw;
    if(px<w-pr){
      ctx.strokeStyle='#182018'; ctx.lineWidth=0.7;
      ctx.beginPath(); ctx.moveTo(px,t); ctx.lineTo(px,h-b); ctx.stroke();
      ctx.fillStyle='#3a7040'; ctx.textAlign='center'; ctx.textBaseline='top';
      ctx.fillText(tv+'Ï€',px,h-b+4);
    }
  });
  ctx.strokeStyle='#ff3db4'; ctx.fillStyle='#ff3db4'; ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.moveTo(l,t); ctx.lineTo(l,h-b+6); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(l-4,t+4); ctx.lineTo(l,t-5); ctx.lineTo(l+4,t+4); ctx.fill();
  ctx.beginPath(); ctx.moveTo(l-6,h-b); ctx.lineTo(w-pr+6,h-b); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(w-pr+2,h-b-4); ctx.lineTo(w-pr+7,h-b); ctx.lineTo(w-pr+2,h-b+4); ctx.fill();
}

function cartXY(t, rv) {
  const {l,r:pr,t:pt,b}=PAD, pw=cCv.width-l-pr, ph=cCv.height-pt-b;
  const yMax=Math.ceil(A+1.2);
  return [l+(t/thetaTotal)*pw, cCv.height-b-(rv/yMax)*ph];
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SPHERE WIREFRAME
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawSphereGrid(ctx) {
  ctx.lineWidth=0.55;
  for(let li=-2; li<=2; li++){
    const lat=(li/3)*Math.PI/2;
    const cosLat=Math.cos(lat), sinLat=Math.sin(lat);
    ctx.beginPath(); let first=true;
    for(let lo=0; lo<=Math.PI*2+0.05; lo+=0.08){
      const x=cosLat*Math.cos(lo), y=sinLat, z=cosLat*Math.sin(lo);
      const [rx,ry,rz]=applyM(rotMat,x,y,z);
      const [px,py]=proj(rx,ry,rz);
      ctx.globalAlpha=Math.max(0.05, 0.06+(rz+1)*0.12);
      ctx.strokeStyle='#3a7040';
      if(first){ctx.moveTo(px,py);first=false;}else ctx.lineTo(px,py);
    }
    ctx.stroke();
  }
  for(let lo=0; lo<8; lo++){
    const lon=(lo/8)*Math.PI*2;
    const cosLon=Math.cos(lon), sinLon=Math.sin(lon);
    ctx.beginPath(); let first=true;
    for(let la=-Math.PI/2; la<=Math.PI/2+0.05; la+=0.08){
      const x=Math.cos(la)*cosLon, y=Math.sin(la), z=Math.cos(la)*sinLon;
      const [rx,ry,rz]=applyM(rotMat,x,y,z);
      const [px,py]=proj(rx,ry,rz);
      ctx.globalAlpha=Math.max(0.05, 0.06+(rz+1)*0.12);
      ctx.strokeStyle='#3a7040';
      if(first){ctx.moveTo(px,py);first=false;}else ctx.lineTo(px,py);
    }
    ctx.stroke();
  }
  ctx.globalAlpha=1;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDER â€” sphere base + per-gap isolated paths
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const HUE_BANDS = 24;

function renderSphere() {
  pCtx.fillStyle='#060608';
  pCtx.fillRect(0,0,pCv.width,pCv.height);
  drawSphereGrid(pCtx);

  const end = Math.floor(drawProgress);
  if (end < 2) return;

  const histFrac = 1 - ((trailFade-1)/39)*0.9;
  const histLen = Math.max(2, Math.floor(end * histFrac));
  const startIdx = Math.max(1, end - histLen);
  const hasGapSel = selectedGaps.size > 0;
  const dimBase = hasGapSel;

  // â”€â”€ Base continuous curve â”€â”€
  const bands = [];
  for(let b=0; b<HUE_BANDS; b++) bands.push({segs:[], bright:0, n:0});
  for(let i=startIdx; i<end; i++){
    const p0=precomputed[i-1], p1=precomputed[i];
    if(!p0||!p1) continue;
    const [rx1,ry1,rz1]=applyM(rotMat,p0[0],p0[1],p0[2]);
    const [rx2,ry2,rz2]=applyM(rotMat,p1[0],p1[1],p1[2]);
    const [px1,py1]=proj(rx1,ry1,rz1);
    const [px2,py2]=proj(rx2,ry2,rz2);
    const depth=(rz1+rz2)*0.5;
    const bi=Math.min(HUE_BANDS-1, Math.floor((i-startIdx)/histLen*HUE_BANDS));
    bands[bi].segs.push(px1,py1,px2,py2);
    bands[bi].bright+=depth; bands[bi].n++;
  }

  if(dimBase){
    for(let bi=0; bi<HUE_BANDS; bi++){
      const bd=bands[bi]; if(!bd.segs.length) continue;
      const avgZ=bd.n>0?bd.bright/bd.n:0;
      pCtx.strokeStyle=`rgba(55,75,55,${Math.max(0.04,0.08+avgZ*0.06)})`;
      pCtx.lineWidth=traceThickness*0.5; pCtx.globalAlpha=1; pCtx.shadowBlur=0;
      pCtx.beginPath();
      for(let j=0;j<bd.segs.length;j+=4){ pCtx.moveTo(bd.segs[j],bd.segs[j+1]); pCtx.lineTo(bd.segs[j+2],bd.segs[j+3]); }
      pCtx.stroke();
    }
  } else {
    pCtx.lineWidth=traceThickness; pCtx.shadowColor='#ff3db4'; pCtx.shadowBlur=4;
    for(let bi=0; bi<HUE_BANDS; bi++){
      const bd=bands[bi]; if(!bd.segs.length) continue;
      const hue=295+(bi/HUE_BANDS)*40;
      const avgZ=bd.n>0?bd.bright/bd.n:0;
      const bright=48+avgZ*22;
      // Use harmonic color if mode active, else standard hue
      const harmBandCol = harmColorMode ? (harmColorForProgress(bi/HUE_BANDS)||`hsl(${hue},100%,${bright}%)`) : `hsl(${hue},100%,${bright}%)`;
      pCtx.strokeStyle = harmBandCol;
      pCtx.globalAlpha=Math.max(0.2, 0.4+avgZ*0.55);
      pCtx.beginPath();
      for(let j=0;j<bd.segs.length;j+=4){ pCtx.moveTo(bd.segs[j],bd.segs[j+1]); pCtx.lineTo(bd.segs[j+2],bd.segs[j+3]); }
      pCtx.stroke();
    }
    pCtx.globalAlpha=1; pCtx.shadowBlur=0;
  }

  // â”€â”€ Per-gap ISOLATED paths: each selected gap draws its own independent orbit â”€â”€
  if(hasGapSel){
    selectedGaps.forEach((col, gv) => {
      // Collect all point indices in [startIdx,end) where gap == gv
      const pts = [];
      for(let i=startIdx; i<end; i++){
        if(precomputed[i] && precomputed[i][4]===gv) pts.push(i);
      }
      if(!pts.length) return;

      // Draw each gap-class point as a glowing dot on its sphere position
      pCtx.shadowColor=col; pCtx.shadowBlur=8; pCtx.globalAlpha=0.85;
      pCtx.fillStyle=col;
      pts.forEach(i=>{
        const p=precomputed[i];
        const [rx,ry,rz]=applyM(rotMat,p[0],p[1],p[2]);
        if(rz < -0.5) return; // hide far side
        const [px,py]=proj(rx,ry,rz);
        const r=Math.max(1.5, traceThickness*0.9);
        pCtx.beginPath(); pCtx.arc(px,py,r,0,Math.PI*2); pCtx.fill();
      });

      // Connect consecutive gap-class points with their own arc (isolated path)
      if(pts.length >= 2){
        pCtx.strokeStyle=col; pCtx.lineWidth=traceThickness*1.2;
        pCtx.shadowColor=col; pCtx.shadowBlur=6; pCtx.globalAlpha=0.7;
        pCtx.beginPath();
        let penDown=false;
        for(let k=0; k<pts.length-1; k++){
          const i=pts[k], j=pts[k+1];
          // Only connect if consecutive in PRIME index space (same gap chain)
          // Allow connect if within 40 indices of each other
          if(j-i <= 40){
            const p0=precomputed[i], p1=precomputed[j];
            const [rx1,ry1,rz1]=applyM(rotMat,p0[0],p0[1],p0[2]);
            const [rx2,ry2,rz2]=applyM(rotMat,p1[0],p1[1],p1[2]);
            if(rz1 < -0.6 && rz2 < -0.6) { penDown=false; continue; }
            const [px1,py1]=proj(rx1,ry1,rz1);
            const [px2,py2]=proj(rx2,ry2,rz2);
            if(!penDown){ pCtx.moveTo(px1,py1); penDown=true; }
            pCtx.lineTo(px2,py2);
          } else { penDown=false; }
        }
        pCtx.stroke();
      }
      pCtx.globalAlpha=1; pCtx.shadowBlur=0;
    });
  }

  // Moving dot
  const cur=precomputed[Math.max(0,end-1)];
  if(cur){
    const [cx,cy,cz]=cur;
    const [rx,ry,rz]=applyM(rotMat,cx,cy,cz);
    const [px,py]=proj(rx,ry,rz);
    pCtx.globalAlpha=Math.max(0.5, 0.5+(rz+1)*0.4);
    pCtx.beginPath(); pCtx.arc(px,py,3.5,0,Math.PI*2);
    pCtx.fillStyle='#fff'; pCtx.shadowColor='#fff'; pCtx.shadowBlur=14;
    pCtx.fill(); pCtx.shadowBlur=0; pCtx.globalAlpha=1;
  }

  // Center glow
  const [crx,cry,crz]=applyM(rotMat,0,0,0);
  const [cpx,cpy]=proj(crx,cry,crz);
  pCtx.beginPath(); pCtx.arc(cpx,cpy,3,0,Math.PI*2);
  pCtx.fillStyle='#ffd700'; pCtx.shadowColor='#ffd700'; pCtx.shadowBlur=16;
  pCtx.fill(); pCtx.shadowBlur=0;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDER CART â€” base curve + per-gap tick marks / isolated segments
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderCart() {
  const newEnd=Math.floor(drawProgress);
  const hasGapSel = selectedGaps.size > 0;

  if(newEnd===0 && lastCartProg>0){ makeCartBuf(); }

  if(newEnd > lastCartProg){
    const cbCtx=cBuf.getContext('2d');
    const {l,r:pr,t:pt,b}=PAD, ph=cCv.height-pt-b;
    const yMax=Math.ceil(A+1.2);

    for(let i=lastCartProg; i<newEnd; i++){
      const t0=(i/TOTAL_PTS)*thetaTotal, t1=((i+1)/TOTAL_PTS)*thetaTotal;
      const r0=f(t0), r1=f(t1);
      const [cx0,cy0]=cartXY(t0,r0), [cx1,cy1]=cartXY(t1,r1);

      if(hasGapSel){
        // Base: very dim
        cbCtx.strokeStyle='rgba(40,60,40,0.18)'; cbCtx.lineWidth=traceThickness*0.4;
        cbCtx.shadowBlur=0;
        cbCtx.beginPath(); cbCtx.moveTo(cx0,cy0); cbCtx.lineTo(cx1,cy1); cbCtx.stroke();

        // Per-gap ticks at each gap occurrence
        const p1=precomputed[i+1];
        const gap=p1?p1[4]:null;
        const selCol=gap!==null?selectedGaps.get(gap):undefined;
        if(selCol){
          // Vertical tick from bottom of plot area at this Î¸ position
          const tickH=Math.min(ph, ph*(0.1 + 0.2));
          cbCtx.strokeStyle=selCol; cbCtx.lineWidth=traceThickness*1.2;
          cbCtx.shadowColor=selCol; cbCtx.shadowBlur=4;
          cbCtx.globalAlpha=0.85;
          cbCtx.beginPath(); cbCtx.moveTo(cx0,cy0-2); cbCtx.lineTo(cx1,cy1-2); cbCtx.stroke();
          // Glow dot at the curve point
          cbCtx.fillStyle=selCol; cbCtx.beginPath();
          cbCtx.arc(cx0,cy0,traceThickness*0.8,0,Math.PI*2); cbCtx.fill();
          cbCtx.shadowBlur=0; cbCtx.globalAlpha=1;
        }
      } else {
        const hue=295+(i/TOTAL_PTS)*40;
        cbCtx.strokeStyle=`hsl(${hue},100%,62%)`;
        cbCtx.lineWidth=traceThickness;
        cbCtx.shadowColor='#ff3db4'; cbCtx.shadowBlur=3;
        cbCtx.beginPath(); cbCtx.moveTo(cx0,cy0); cbCtx.lineTo(cx1,cy1); cbCtx.stroke();
        cbCtx.shadowBlur=0;
      }
    }
    lastCartProg=newEnd;
  }
  cCtx.clearRect(0,0,cCv.width,cCv.height);
  cCtx.drawImage(cBuf,0,0);
}

// When gap selection changes, we need to redraw the cart buffer from scratch
function invalidateCartBuf(){
  makeCartBuf();
  lastCartProg = 0;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  LIVE STATS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateLiveStats() {
  const end = Math.floor(drawProgress);
  const pct = TOTAL_PTS > 0 ? ((end / TOTAL_PTS) * 100).toFixed(1) : '0.0';
  const t = (end / TOTAL_PTS) * thetaTotal;
  const tPi = (t / Math.PI).toFixed(2);
  const fv = end > 0 ? f(t).toFixed(4) : 'â€”';
  document.getElementById('stProg').textContent = pct + '%';
  document.getElementById('stTheta').textContent = tPi + 'Ï€';
  document.getElementById('stFTheta').textContent = fv;
  document.getElementById('stPts').textContent = end.toLocaleString();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ANIMATION LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function loop() {
  requestAnimationFrame(loop);
  if(autoRotate) rotMat=mmul(mrotY(0.008), rotMat);
  if(!paused){
    drawProgress += speed;
    if(drawProgress >= TOTAL_PTS){
      if(looping){ drawProgress = 0; }
      else {
        drawProgress = TOTAL_PTS; paused = true;
        const btn = document.getElementById('btnPlay');
        btn.textContent = 'â–¶ Play'; btn.classList.remove('on');
      }
    }
  }
  renderSphere();
  renderCart();
  updateLiveStats();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  HARD RESET
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function hardReset() {
  drawProgress=0; lastCartProg=0;
  precompute(); makeCartBuf(); updateFormula();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DRAG ROTATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function onDragStart(ex,ey){ isDrag=true; lastMX=ex; lastMY=ey; }
function onDragMove(ex,ey){
  if(!isDrag) return;
  const dx=ex-lastMX, dy=ey-lastMY;
  lastMX=ex; lastMY=ey;
  const s=0.012;
  rotMat=mmul(mrotY(dx*s), rotMat);
  rotMat=mmul(mrotX(dy*s), rotMat);
}
function onDragEnd(){ isDrag=false; }

pCv.addEventListener('mousedown', e=>{ e.preventDefault(); onDragStart(e.clientX,e.clientY); });
window.addEventListener('mousemove', e=>onDragMove(e.clientX,e.clientY));
window.addEventListener('mouseup', onDragEnd);
pCv.addEventListener('touchstart', e=>{ e.preventDefault(); const t=e.touches[0]; onDragStart(t.clientX,t.clientY); },{passive:false});
pCv.addEventListener('touchmove',  e=>{ e.preventDefault(); const t=e.touches[0]; onDragMove(t.clientX,t.clientY); },{passive:false});
pCv.addEventListener('touchend',   onDragEnd);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ROTATION BUTTONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.getElementById('btnAutoRot').addEventListener('click',function(){
  autoRotate=!autoRotate;
  this.classList.toggle('on',autoRotate);
  this.textContent=autoRotate?'âŸ³ Rotating...':'âŸ³ Auto-Rotate';
});
document.getElementById('btnResetRot').addEventListener('click',()=>{
  rotMat=[1,0,0, 0,1,0, 0,0,1];
  autoRotate=false;
  const b=document.getElementById('btnAutoRot');
  b.classList.remove('on'); b.textContent='âŸ³ Auto-Rotate';
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SPEED & THICKNESS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function setSpeed(v){
  speed=v;
  document.getElementById('sSpeed').value=v;
  document.getElementById('dSpeed').textContent=v.toFixed(2);
  updateSpeedDesc(v);
}
function updateSpeedDesc(v){
  const el=document.getElementById('speedDesc');
  if(v<0.2) el.textContent='ultra slow';
  else if(v<1) el.textContent='crawl';
  else if(v<4) el.textContent='slow';
  else if(v<12) el.textContent='normal';
  else if(v<25) el.textContent='fast';
  else el.textContent='maximum';
}

// Thickness slider
document.getElementById('gdThick').addEventListener('input', function(){
  traceThickness = parseFloat(this.value);
  document.getElementById('gdThickVal').textContent = traceThickness.toFixed(2)+'px';
  // Invalidate cart buf so it redraws with new thickness
  invalidateCartBuf();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  LOOP TOGGLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.getElementById('cbLoop').addEventListener('change', function(){
  looping = this.checked;
  document.getElementById('loopState').textContent = looping ? 'on â€” loops forever' : 'off â€” stops at end';
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SLIDER BINDINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function bind(id,dId,setter,fmt,noReset){
  document.getElementById(id).addEventListener('input',function(){
    const v=parseFloat(this.value);
    setter(v);
    document.getElementById(dId).textContent=fmt?fmt(v):v;
    if(!noReset) hardReset();
  });
}
bind('sA','dA',v=>A=v);
bind('sB','dB',v=>B=v);
bind('sC','dC',v=>C=v);
bind('sD','dD',v=>D=v);
bind('sTheta','dTheta',v=>thetaTotal=v*Math.PI,v=>v+'Ï€');
bind('sTrail','dTrail',v=>trailFade=v,null,true);
bind('sSpeed','dSpeed',v=>{speed=v;updateSpeedDesc(v);},v=>v.toFixed(2),true);

document.getElementById('btnPlay').addEventListener('click',function(){
  paused=!paused;
  this.textContent=paused?'â–¶ Play':'â¸ Pause';
  this.classList.toggle('on',!paused);
});
document.getElementById('btnReset').addEventListener('click',()=>{ hardReset(); });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  4K SPHERE EXPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.getElementById('btnExport4K').addEventListener('click', exportSphere4K);

function exportSphere4K() {
  const SIZE = 3840;
  const cv = document.createElement('canvas');
  cv.width = cv.height = SIZE;
  const ctx = cv.getContext('2d');
  ctx.fillStyle = '#060608'; ctx.fillRect(0,0,SIZE,SIZE);

  ctx.lineWidth = 1.5;
  for(let li=-2; li<=2; li++){
    const lat=(li/3)*Math.PI/2, cosLat=Math.cos(lat), sinLat=Math.sin(lat);
    ctx.beginPath(); let first=true;
    for(let lo=0; lo<=Math.PI*2+0.05; lo+=0.04){
      const x=cosLat*Math.cos(lo), y=sinLat, z=cosLat*Math.sin(lo);
      const [rx,ry,rz]=applyM(rotMat,x,y,z);
      const fov=2.8, sc=fov/(fov-rz), R=SIZE*0.37;
      const px=SIZE/2+rx*R*sc, py=SIZE/2-ry*R*sc;
      ctx.globalAlpha=Math.max(0.05, 0.06+(rz+1)*0.12); ctx.strokeStyle='#3a7040';
      if(first){ctx.moveTo(px,py);first=false;}else ctx.lineTo(px,py);
    } ctx.stroke();
  }
  for(let lo=0; lo<8; lo++){
    const lon=(lo/8)*Math.PI*2, cosLon=Math.cos(lon), sinLon=Math.sin(lon);
    ctx.beginPath(); let first=true;
    for(let la=-Math.PI/2; la<=Math.PI/2+0.05; la+=0.04){
      const x=Math.cos(la)*cosLon, y=Math.sin(la), z=Math.cos(la)*sinLon;
      const [rx,ry,rz]=applyM(rotMat,x,y,z);
      const fov=2.8, sc=fov/(fov-rz), R=SIZE*0.37;
      const px=SIZE/2+rx*R*sc, py=SIZE/2-ry*R*sc;
      ctx.globalAlpha=Math.max(0.05, 0.06+(rz+1)*0.12); ctx.strokeStyle='#3a7040';
      if(first){ctx.moveTo(px,py);first=false;}else ctx.lineTo(px,py);
    } ctx.stroke();
  }
  ctx.globalAlpha=1;

  const end = Math.floor(drawProgress);
  if(end >= 2){
    const histFrac = 1 - ((trailFade-1)/39)*0.9;
    const histLen = Math.max(2, Math.floor(end * histFrac));
    const startIdx = Math.max(1, end - histLen);
    for(let i=startIdx; i<end; i++){
      const p0=precomputed[i-1], p1=precomputed[i];
      if(!p0||!p1) continue;
      const [rx1,ry1,rz1]=applyM(rotMat,p0[0],p0[1],p0[2]);
      const [rx2,ry2,rz2]=applyM(rotMat,p1[0],p1[1],p1[2]);
      const fov=2.8, R=SIZE*0.37;
      const s1=fov/(fov-rz1), s2=fov/(fov-rz2);
      const px1=SIZE/2+rx1*R*s1, py1=SIZE/2-ry1*R*s1;
      const px2=SIZE/2+rx2*R*s2, py2=SIZE/2-ry2*R*s2;
      const gap = p1[4];
      const selCol = gap !== null ? selectedGaps.get(gap) : undefined;
      if (selCol) {
        ctx.strokeStyle = selCol; ctx.lineWidth = traceThickness*2.5;
        ctx.shadowColor=selCol; ctx.shadowBlur=10;
      } else {
        const bi=Math.min(HUE_BANDS-1, Math.floor((i-startIdx)/histLen*HUE_BANDS));
        const hue=295+(bi/HUE_BANDS)*40;
        const avgZ=(rz1+rz2)*0.5, bright=48+avgZ*22;
        ctx.strokeStyle=`hsl(${hue},100%,${bright}%)`;
        ctx.lineWidth=traceThickness*2; ctx.shadowColor='#ff3db4'; ctx.shadowBlur=8;
      }
      ctx.globalAlpha=Math.max(0.2, 0.5);
      ctx.beginPath(); ctx.moveTo(px1,py1); ctx.lineTo(px2,py2); ctx.stroke();
    }
    ctx.shadowBlur=0; ctx.globalAlpha=1;
  }

  ctx.globalAlpha=0.7; ctx.fillStyle='#ffd700';
  ctx.font='bold 48px JetBrains Mono, monospace'; ctx.textAlign='left';
  ctx.fillText(`f(Î¸) = ${A} + sin(${B}Î¸)Â·sin(${C}Î¸/${D})  |  Î¸âˆˆ[0,${Math.round(thetaTotal/Math.PI)}Ï€]`, 60, SIZE-80);
  ctx.globalAlpha=0.4; ctx.font='32px JetBrains Mono, monospace'; ctx.fillStyle='#ff3db4';
  ctx.fillText('Polar vs Cartesian Â· Wessen Getachew Â· @7dview', 60, SIZE-36);
  ctx.globalAlpha=1;

  const link = document.createElement('a');
  link.download = `polar_sphere_4K_A${A}_B${B}_C${C}_D${D}.png`;
  link.href = cv.toDataURL('image/png'); link.click();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BUILD PRESETS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let activePresetBtn = null;

function buildPresets(){
  Object.entries(PRESET_GROUPS).forEach(([gid, list])=>{
    const row = document.getElementById(gid);
    if(!row) return;
    list.forEach((p,i)=>{
      const btn = document.createElement('button');
      btn.className = 'preset-btn';
      btn.textContent = p.name;
      if(gid==='pgClassic'&&i===0){ btn.classList.add('active'); activePresetBtn=btn; }
      btn.onclick = ()=> applyPreset(p, btn, gid==='pgGapWave');
      row.appendChild(btn);
    });
  });
}

function applyPreset(p, btn, isGap){
  A=p.A; B=p.B; C=p.C; D=p.D; thetaTotal=p.theta*Math.PI; trailFade=p.trail||6;
  const sl=(id,v,fmt)=>{ document.getElementById(id).value=v; document.getElementById('d'+id.slice(1)).textContent=fmt?fmt(v):v; };
  sl('sA',A); sl('sB',B); sl('sC',C); sl('sD',D);
  sl('sTheta',p.theta,v=>v+'Ï€');
  sl('sTrail',trailFade);
  if(activePresetBtn) activePresetBtn.classList.remove('active','gap-active');
  if(btn){ btn.classList.add(isGap?'gap-active':'active'); activePresetBtn=btn; }
  hardReset();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAP DECOMPOSITION MODULE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.getElementById('gapHeader').addEventListener('click',()=>{
  const body = document.getElementById('gapBody');
  const chev = document.getElementById('gapChevron');
  const hdr  = document.getElementById('gapHeader');
  body.classList.toggle('open');
  chev.classList.toggle('open');
  hdr.classList.toggle('open');
});

document.getElementById('gdN').addEventListener('input', function(){
  document.getElementById('gdND').textContent = parseInt(this.value).toLocaleString();
});
document.getElementById('gdS').addEventListener('input', function(){
  document.getElementById('gdSD').textContent = `s = ${parseFloat(this.value).toFixed(2)}`;
});

let gdData = null;
let gdTab = 'contrib';
let gdFilter = 'all';
const gdCanvas = document.getElementById('gapCanvas');
const gdCtx = gdCanvas.getContext('2d');
let gdActiveWaveBtn = null;

function gdResizeCanvas(){
  const w = Math.min(window.innerWidth - 68, 524);
  gdCanvas.width = Math.max(280, w);
  if(gdData) gdDraw();
}
window.addEventListener('resize', gdResizeCanvas);
gdResizeCanvas();

function setGapFilter(btn, filter){
  document.querySelectorAll('.gap-filter-btn').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');
  gdFilter = filter;
}

// â”€â”€ Sieves â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function simpleSieve(max){
  const sieve = new Uint8Array(max+1).fill(1);
  sieve[0]=sieve[1]=0;
  for(let i=2;i*i<=max;i++) if(sieve[i]) for(let j=i*i;j<=max;j+=i) sieve[j]=0;
  const primes=[];
  for(let i=2;i<=max;i++) if(sieve[i]) primes.push(i);
  return primes;
}

function segmentedSieve(max, progressCb){
  const sqrtMax = Math.ceil(Math.sqrt(max));
  const small = simpleSieve(sqrtMax);
  const primes = [];
  const SEG = 1<<20;
  for(let lo=0; lo<=max; lo+=SEG){
    const hi = Math.min(lo+SEG-1, max);
    const seg = new Uint8Array(hi-lo+1).fill(1);
    for(const p of small){
      let start = Math.max(p*p, Math.ceil(lo/p)*p);
      for(let j=start; j<=hi; j+=p) seg[j-lo]=0;
    }
    for(let i=(lo<2?2:lo); i<=hi; i++) if(seg[i-lo]) primes.push(i);
    if(progressCb) progressCb(hi, max);
  }
  return primes;
}

// â”€â”€ Core analysis â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function knownZeta(s){
  const k = {2:Math.PI**2/6, 4:Math.PI**4/90, 6:Math.PI**6/945, 8:Math.PI**8/9450, 10:Math.PI**10/93555};
  return k[Math.round(s*100)/100] || null;
}

function gdCompute(maxN, s, filter, progressCb){
  const primes = maxN < 5e6 ? simpleSieve(maxN) : segmentedSieve(maxN, progressCb);

  let target = knownZeta(s);
  if(!target) target = primes.reduce((p, pr) => p * Math.pow(pr,s)/(Math.pow(pr,s)-1), 1);

  const gapFamilies = {};
  for(let i=0; i<primes.length-1; i++){
    const g = primes[i+1]-primes[i];
    if(!gapFamilies[g]) gapFamilies[g]=[];
    gapFamilies[g].push(primes[i]);
  }

  let gaps = Object.keys(gapFamilies).map(Number).sort((a,b)=>a-b);

  if(filter==='tiny')   gaps = gaps.filter(g=>g>=2&&g<=10);
  if(filter==='small')  gaps = gaps.filter(g=>g>=2&&g<=30);
  if(filter==='medium') gaps = gaps.filter(g=>g>=20&&g<=80);
  if(filter==='large')  gaps = gaps.filter(g=>g>=50&&g<=200);

  const gapProducts = {};
  let totalLog = 0;
  gaps.forEach(g=>{
    const ps = gapFamilies[g];
    if(!ps||!ps.length) return;
    let prod=1, logProd=0;
    ps.forEach(p=>{
      const ps_s = Math.pow(p,s);
      const fac = ps_s/(ps_s-1);
      prod *= fac; logProd += Math.log(fac);
    });
    gapProducts[g] = { product:prod, logProduct:logProd, count:ps.length };
    totalLog += logProd;
  });

  // Convergence steps
  const conv = [];
  let cum = 1, prevCum = 1;
  gaps.forEach((g,idx)=>{
    if(!gapProducts[g]) return;
    prevCum = cum;
    cum *= gapProducts[g].product;
    const relErr = Math.abs(cum-target)/target;
    const pi_est = s >= 1.99 && s <= 2.01 ? Math.sqrt(6*cum) : null;
    const delta = cum - prevCum;
    conv.push({ gap:g, value:cum, relErr, prevErr: idx>0?conv[idx-1]?.relErr??null:null,
                pi_est, delta, logProduct:gapProducts[g].logProduct, step:idx+1 });
  });

  const c2 = gapFamilies[2]?.length||0;
  const c4 = gapFamilies[4]?.length||0;
  const c6 = gapFamilies[6]?.length||0;

  let mostCommon = gaps[0], mcCount = 0;
  gaps.forEach(g=>{ if((gapFamilies[g]?.length||0)>mcCount){ mcCount=gapFamilies[g].length; mostCommon=g; }});

  const finalErr = Math.abs(cum-target)/target;
  const pi_calc = (s >= 1.99 && s <= 2.01) ? Math.sqrt(6*cum) : null;

  // Build gapâ†’index map for color assignment
  gapIndexMap = {};
  gaps.forEach((g,i) => { gapIndexMap[g] = i; });

  return { primes, gaps, gapFamilies, gapProducts, conv, target, totalLog,
           finalProduct:cum, finalError:finalErr, s, maxN,
           c2,c4,c6, mostCommon, mcCount, pi_calc };
}

// â”€â”€ Run â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gdRun(){
  const maxN = parseInt(document.getElementById('gdN').value);
  const s = parseFloat(document.getElementById('gdS').value);
  const filter = gdFilter;

  if(maxN > 300000000){
    document.getElementById('gdStatus').textContent = 'âš  Max N is 300,000,000 (browser limit).';
    return;
  }

  document.getElementById('gdStatus').textContent = 'Sieving primesâ€¦';
  document.getElementById('gdRunBtn').disabled = true;
  document.getElementById('gdProgress').style.display = 'block';
  document.getElementById('gdProgressFill').style.width = '0%';

  setTimeout(()=>{
    try {
      const progressCb = (cur, max)=>{
        const pct = Math.min(99, (cur/max*100)).toFixed(0);
        document.getElementById('gdProgressFill').style.width = pct+'%';
        document.getElementById('gdStatus').textContent = `Sievingâ€¦ ${pct}%  (${cur.toLocaleString()} / ${max.toLocaleString()})`;
      };

      gdData = gdCompute(maxN, s, filter, progressCb);

      document.getElementById('gdProgressFill').style.width = '100%';
      setTimeout(()=>document.getElementById('gdProgress').style.display='none', 400);

      const errPct = (gdData.finalError*100).toFixed(8);
      document.getElementById('gdStatus').textContent =
        `âœ“ N=${maxN.toLocaleString()} Â· ${gdData.primes.length.toLocaleString()} primes Â· `+
        `${gdData.gaps.length} gap families Â· `+
        `Î¶(${s.toFixed(2)}) target=${gdData.target.toFixed(10)} Â· `+
        `computed=${gdData.finalProduct.toFixed(10)} Â· err=${errPct}%`;

      updateGdStats();

      ['gdExportPNG','gdExportCSV','gdExportTXT'].forEach(id=>document.getElementById(id).style.display='inline-block');
      document.getElementById('gdTabs').style.display='flex';
      document.getElementById('gdStatsGrid').style.display='grid';

      // Build gap chip selectors (panel + main area)
      buildGapChips();
      // Rebuild top-level Gap Waves preset row with all computed families
      buildAllGapWavePresets();

      // Build stats table and convergence table
      gdBuildTable();
      gdBuildConvTable();
      document.getElementById('gdTableSection').style.display='block';
      document.getElementById('gdConvSection').style.display='block';


      // Recompute sphere with gap data
      precompute();
      invalidateCartBuf();

      gdResizeCanvas();
      gdDraw();

    } catch(e) {
      document.getElementById('gdStatus').textContent = `Error: ${e.message}`;
      console.error(e);
    }
    document.getElementById('gdRunBtn').disabled = false;
  }, 20);
}

function updateGdStats(){
  if(!gdData) return;
  const d = gdData;
  const pi_str = d.pi_calc ? d.pi_calc.toFixed(10) : 'n/a (sâ‰ 2)';
  const vals = [
    d.primes.length.toLocaleString(), d.gaps.length,
    Math.max(...d.gaps), d.target.toFixed(10), d.finalProduct.toFixed(10),
    (d.finalError*100).toFixed(10)+'%', d.c2.toLocaleString(),
    d.c4.toLocaleString(), d.c6.toLocaleString(),
    `${d.mostCommon} (${d.mcCount.toLocaleString()}Ã—)`,
    d.c4>0 ? (d.c2/d.c4).toFixed(6) : 'n/a', pi_str,
  ];
  vals.forEach((v,i)=>{ const el=document.getElementById('gst'+i); if(el) el.textContent=v; });
}

function gdClear(){
  gdData = null; selectedGaps.clear(); gapIndexMap = {};
  gdCtx.clearRect(0,0,gdCanvas.width,gdCanvas.height);
  document.getElementById('gdStatus').textContent='Run decomposition to analyze prime gap contributions to Î¶(s).';
  ['gdExportPNG','gdExportCSV','gdExportTXT'].forEach(id=>document.getElementById(id).style.display='none');
  document.getElementById('gdTabs').style.display='none';
  document.getElementById('gdStatsGrid').style.display='none';
    document.getElementById('gdSelectorWrap').style.display='none';
  document.getElementById('mainGapSelector').style.display='none';
  document.getElementById('mainGapChips').innerHTML='';
  document.getElementById('pgGapWave').innerHTML='';
  document.getElementById('gdTableSection').style.display='none';
  document.getElementById('gdConvSection').style.display='none';
  document.getElementById('gdLegend').innerHTML='';
  document.getElementById('gdChips').innerHTML='';
  precompute(); invalidateCartBuf();
}

function gdSwitchTab(btn, tab){
  gdTab = tab;
  document.querySelectorAll('.gap-tab').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');
  if(gdData) gdDraw();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAP CHIP SELECTOR (multi-select)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildGapChips(){
  if(!gdData) return;

  // Build chips for BOTH containers (panel + main area)
  const containers = [
    { row: document.getElementById('gdChips'), wrap: document.getElementById('gdSelectorWrap') },
    { row: document.getElementById('mainGapChips'), wrap: document.getElementById('mainGapSelector') },
  ];

  containers.forEach(({row, wrap}) => {
    row.innerHTML = '';
    gdData.gaps.forEach((g, i) => {
      const col = gapColor(g, i);
      const chip = document.createElement('div');
      chip.className = 'gap-chip';
      chip.dataset.gap = g;
      chip.innerHTML = `<span class="chip-dot" style="background:${col}"></span>g=${g}`;
      chip.title = `Gap ${g}: ${(gdData.gapProducts[g]?.count||0).toLocaleString()} primes`;
      chip.addEventListener('click', ()=> toggleGapChipAll(g, i, col));
      row.appendChild(chip);
    });
    wrap.style.display = 'block';
  });
}

// Toggle all chips with matching gap value across both containers
function toggleGapChipAll(g, idx, col){
  const isSelected = selectedGaps.has(g);
  if(isSelected){
    selectedGaps.delete(g);
  } else {
    selectedGaps.set(g, col);
  }
  // Update ALL chips for this gap
  document.querySelectorAll(`.gap-chip[data-gap="${g}"]`).forEach(chip => {
    if(selectedGaps.has(g)){
      chip.classList.add('selected');
      chip.style.background = col;
      chip.style.borderColor = col;
      chip.style.color = '#000';
    } else {
      chip.classList.remove('selected');
      chip.style.background = '';
      chip.style.borderColor = '';
      chip.style.color = '';
    }
  });
  invalidateCartBuf();
}

function toggleGapChip(g, idx, chip, col){
  toggleGapChipAll(g, idx, col);
}

function gdClearSelection(){
  selectedGaps.clear();
  document.querySelectorAll('.gap-chip.selected').forEach(c=>{
    c.classList.remove('selected');
    c.style.background = '';
    c.style.borderColor = '';
    c.style.color = '';
  });
  invalidateCartBuf();
  if(gdData) gdDraw();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ALL-GAPS STATS TABLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function gdBuildTable(){
  if(!gdData) return;
  const {gaps, gapProducts, gapFamilies, totalLog, target, s} = gdData;
  const dec = Math.max(2, Math.min(20, parseInt(document.getElementById('gdTableDec').value)||8));
  const sortBy = document.getElementById('gdTableSort').value;
  const topN = parseInt(document.getElementById('gdTableTop').value)||0;
  const hlSel = document.getElementById('gdTableHighlight').checked;

  let rows = gaps.filter(g=>gapProducts[g]).map((g,i)=>{
    const gp = gapProducts[g];
    const logShare = gp.logProduct / (totalLog||1) * 100;
    let cum=1;
    gaps.forEach(gg=>{ if(gg<=g && gapProducts[gg]) cum*=gapProducts[gg].product; });
    return { g, count:gp.count, product:gp.product, logProduct:gp.logProduct,
             logShare, cumulative:cum, relErr:Math.abs(cum-target)/target,
             pctPrimes:gp.count/(gdData.primes.length||1)*100, i };
  });

  if(sortBy==='count_desc') rows.sort((a,b)=>b.count-a.count);
  else if(sortBy==='logshare_desc') rows.sort((a,b)=>b.logShare-a.logShare);
  else if(sortBy==='product_desc') rows.sort((a,b)=>b.product-a.product);
  else if(sortBy==='cumulative') rows.sort((a,b)=>a.cumulative-b.cumulative);
  else rows.sort((a,b)=>a.g-b.g);

  if(topN>0) rows = rows.slice(0, topN);

  const fmt = (v, d) => typeof v === 'number' ? v.toFixed(d) : v;
  const fmtE = (v, d) => v < 1e-4 ? v.toExponential(d) : v.toFixed(d);

  let html = `<table>
    <thead><tr>
      <th>Gap</th>
      <th>Count</th>
      <th>% of primes</th>
      <th>Product</th>
      <th>log(Product)</th>
      <th>log-Î¶ share %</th>
      <th>Cumulative</th>
      <th>Rel. error</th>
      <th>Abs. error</th>
    </tr></thead><tbody>`;

  rows.forEach(r=>{
    const col = gapColor(r.g, r.i);
    const isSel = hlSel && selectedGaps.has(r.g);
    const selClass = isSel ? 'gap-row-selected' : '';
    const abErr = Math.abs(r.cumulative - target);
    html += `<tr class="${selClass}">
      <td class="gap-id" style="color:${col}">${r.g}</td>
      <td>${r.count.toLocaleString()}</td>
      <td>${fmt(r.pctPrimes, dec)}%</td>
      <td>${fmt(r.product, dec)}</td>
      <td>${fmt(r.logProduct, dec)}</td>
      <td>${fmt(r.logShare, dec)}%</td>
      <td>${fmt(r.cumulative, dec)}</td>
      <td>${fmtE(r.relErr, dec)}</td>
      <td>${fmtE(abErr, dec)}</td>
    </tr>`;
  });
  html += '</tbody></table>';
  document.getElementById('gdTableWrap').innerHTML = html;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONVERGENCE TO Ï€Â²/6 TABLE (dropdown)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.getElementById('convDropHeader').addEventListener('click', ()=>{
  document.getElementById('convDropBody').classList.toggle('open');
  document.getElementById('convDropChev').classList.toggle('open');
});

function gdBuildConvTable(){
  if(!gdData) return;
  const {conv, target, s, gaps, gapProducts, totalLog} = gdData;
  const dec = Math.max(2, Math.min(20, parseInt(document.getElementById('convDec').value)||12));
  const sortKey = document.getElementById('convSort').value;
  const topN = parseInt(document.getElementById('convTop').value)||0;
  const showPi = document.getElementById('convShowPi').checked;
  const showLog = document.getElementById('convShowLog').checked;
  const showDelta = document.getElementById('convShowDelta').checked;

  const isZeta2 = s >= 1.99 && s <= 2.01;
  const TARGET_PI2_6 = Math.PI**2/6;

  // Build full row data: one row per gap step
  let rows = conv.map((c, i)=>{
    const gp = gapProducts[c.gap];
    const logShare = gp ? gp.logProduct/(totalLog||1)*100 : 0;
    const logErr = c.relErr > 0 ? Math.log10(c.relErr) : -Infinity;
    const improving = i>0 ? c.relErr < conv[i-1].relErr : true;
    return { ...c, logShare, logErr, improving, step:i+1 };
  });

  if(sortKey==='logshare_desc') rows = [...rows].sort((a,b)=>b.logShare-a.logShare);
  else if(sortKey==='cumulative_asc') rows = [...rows].sort((a,b)=>a.value-b.value);
  else if(sortKey==='relerr_asc') rows = [...rows].sort((a,b)=>a.relErr-b.relErr);
  // else natural gap order

  if(topN>0) rows = rows.slice(0, topN);

  // Best row (minimum relative error)
  const bestRelErr = Math.min(...rows.map(r=>r.relErr));

  const fmt = (v, d) => typeof v === 'number' ? v.toFixed(d) : 'â€”';
  const fmtE = (v, d) => (v===null||v===undefined) ? 'â€”' : v < 1e-4 ? v.toExponential(d) : v.toFixed(d);

  let ths = `<th>Step</th><th>Gap</th><th>log-Î¶ %</th>
    <th class="conv-cell-product">Cumulative product</th>
    <th>Target Î¶(${s.toFixed(2)})</th>
    <th class="conv-cell-err">Rel. error</th>
    <th>Abs. error</th>`;
  if(showLog) ths += `<th class="conv-cell-logerr">logâ‚â‚€(err)</th>`;
  if(showDelta) ths += `<th>Î” product</th>`;
  if(showPi && isZeta2) ths += `<th class="conv-cell-pi">âˆš(6Â·prod) â‰ˆ Ï€</th><th class="conv-cell-pi">|Ï€ est âˆ’ Ï€|</th>`;

  let html = `<table><thead><tr>${ths}</tr></thead><tbody>`;

  rows.forEach(r=>{
    const isBest = r.relErr === bestRelErr;
    const rowClass = isBest ? 'conv-row-best' : r.improving ? 'conv-row-improving' : 'conv-row-worsening';
    const col = gapColor(r.gap, gapIndexMap[r.gap]||0);
    const abErr = Math.abs(r.value - target);
    const pi_est = (showPi && isZeta2 && r.value > 0) ? Math.sqrt(6*r.value) : null;
    const pi_err = pi_est !== null ? Math.abs(pi_est - Math.PI) : null;

    let tds = `
      <td>${r.step}</td>
      <td class="conv-cell-gap" style="color:${col}">g=${r.gap}</td>
      <td>${fmt(r.logShare, dec)}%</td>
      <td class="conv-cell-product">${fmt(r.value, dec)}</td>
      <td>${fmt(target, dec)}</td>
      <td class="conv-cell-err">${fmtE(r.relErr, dec)}</td>
      <td>${fmtE(abErr, dec)}</td>`;
    if(showLog) tds += `<td class="conv-cell-logerr">${isFinite(r.logErr)?fmt(r.logErr,dec):'â€”'}</td>`;
    if(showDelta) tds += `<td>${fmtE(Math.abs(r.delta), dec)}</td>`;
    if(showPi && isZeta2){
      tds += `<td class="conv-cell-pi">${pi_est!==null?fmt(pi_est,dec):'â€”'}</td>`;
      tds += `<td class="conv-cell-pi">${pi_err!==null?fmtE(pi_err,dec):'â€”'}</td>`;
    }

    html += `<tr class="${rowClass}">${tds}</tr>`;
  });
  html += '</tbody></table>';
  document.getElementById('gdConvTableWrap').innerHTML = html;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  REFINED WAVE PRESETS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Rebuild the top-level pgGapWave preset row with ALL computed gap families
function buildAllGapWavePresets(){
  if(!gdData) return;
  const { gaps, gapProducts, totalLog, maxN } = gdData;
  const row = document.getElementById('pgGapWave');
  row.innerHTML = '';

  // First show a label update
  const lbl = row.previousElementSibling;
  if(lbl) lbl.textContent = `Gap Waves Â· ${maxN.toLocaleString()} primes â€” all ${gaps.length} families`;

  gaps.filter(g=>gapProducts[g]).forEach((g, i) => {
    const gp = gapProducts[g];
    const logShare = gp.logProduct / (totalLog||1);
    const col = gapColor(g, i);

    // Derive parameters from gap data
    const Ap = parseFloat(Math.max(0.5, Math.min(3.5, 1.0 + logShare * 3)).toFixed(2));
    const Bp = Math.max(1, Math.min(12, Math.floor(g/4)));
    const Cp = Math.max(1, Math.min(12, g));
    const Dp = Math.min(128, Math.max(4, g));
    const theta = Math.min(300, Math.max(32, g * 12));
    const trail = g <= 4 ? 7 : g <= 8 ? 6 : g <= 16 ? 5 : g <= 32 ? 4 : 3;

    const btn = document.createElement('button');
    btn.className = 'preset-btn';
    btn.style.borderColor = col + '66';
    btn.style.color = col;
    btn.textContent = 'g=' + g;
    btn.title = `Gap ${g}: ${gp.count.toLocaleString()} primes (${(logShare*100).toFixed(2)}% log-Î¶)
A=${Ap} B=${Bp} C=${Cp} D=${Dp} Î¸=${theta}Ï€`;
    btn.onclick = () => {
      const preset = { name:'Gap '+g, A:Ap, B:Bp, C:Cp, D:Dp, theta, trail, gap:g };
      if(activePresetBtn) activePresetBtn.classList.remove('active','gap-active');
      btn.classList.add('gap-active'); activePresetBtn = btn;
      A=Ap; B=Bp; C=Cp; D=Dp; thetaTotal=theta*Math.PI; trailFade=trail;
      ['sA','sB','sC','sD'].forEach(id=>{
        const map={sA:Ap,sB:Bp,sC:Cp,sD:Dp};
        document.getElementById(id).value=map[id];
        document.getElementById('d'+id[1]).textContent=map[id];
      });
      document.getElementById('sTheta').value=theta;
      document.getElementById('dTheta').textContent=theta+'Ï€';
      document.getElementById('sTrail').value=trail;
      document.getElementById('dTrail').textContent=trail;
      hardReset();
    };
    row.appendChild(btn);
  });
}

function buildRefinedWavePresets(){ /* merged into buildAllGapWavePresets */ }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CHART DRAWING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function gdDraw(){
  if(!gdData) return;
  const w=gdCanvas.width, h=gdCanvas.height;
  gdCtx.fillStyle='#060608'; gdCtx.fillRect(0,0,w,h);
  if(gdTab==='contrib') gdDrawContrib(w,h);
  else if(gdTab==='dist') gdDrawDist(w,h);
  else if(gdTab==='conv') gdDrawConv(w,h);
  else if(gdTab==='ratio') gdDrawRatio(w,h);
  else if(gdTab==='pct') gdDrawPct(w,h);
}

function gPad(){ return {l:60,r:14,t:28,b:42}; }
function gdTitle(ctx, w, txt){
  ctx.fillStyle='#ffd700'; ctx.textAlign='left';
  ctx.font=`bold ${Math.max(9,w*.022)}px JetBrains Mono,monospace`;
  ctx.fillText(txt, 60, 18);
}

function gdDrawContrib(w, h){
  const {gaps, gapProducts, totalLog, s} = gdData;
  if(!gaps.length) return;
  const p=gPad(), pw=w-p.l-p.r, ph=h-p.t-p.b;
  const ctx=gdCtx;
  const shares = gaps.map(g=>(gapProducts[g]?.logProduct||0)/totalLog*100);
  const maxS = Math.max(...shares);
  const barW = pw/gaps.length;

  ctx.font=`${Math.max(7,w*.018)}px JetBrains Mono,monospace`;
  gaps.forEach((g,i)=>{
    const pct=shares[i], bh=pct/maxS*ph;
    const x=p.l+i*barW, y=p.t+ph-bh;
    const col=gapColor(g,i);
    const isSel = selectedGaps.has(g);
    ctx.fillStyle=col+(isSel?'bb':'33'); ctx.fillRect(x+1,y,barW-2,bh);
    ctx.strokeStyle=col; ctx.lineWidth=isSel?2.5:1.2;
    ctx.strokeRect(x+1,y,barW-2,bh);
    if(barW>18){ ctx.fillStyle=col; ctx.textAlign='center'; ctx.fillText(''+g, x+barW/2, p.t+ph+16); }
    if(barW>28&&pct>0.5){ ctx.fillStyle='#fff'; ctx.globalAlpha=0.8; ctx.fillText(pct.toFixed(1)+'%', x+barW/2, y-3); ctx.globalAlpha=1; }
  });
  [0,25,50,75,100].forEach(pct=>{
    if(pct<=maxS*1.1){ const y=p.t+ph-pct/maxS*ph;
      ctx.strokeStyle='#182018'; ctx.lineWidth=0.5;
      ctx.beginPath(); ctx.moveTo(p.l,y); ctx.lineTo(w-p.r,y); ctx.stroke();
      ctx.fillStyle='#3a7040'; ctx.textAlign='right'; ctx.textBaseline='middle';
      ctx.fillText(pct+'%', p.l-4, y);
    }
  });
  gdTitle(ctx, w, `log-Î¶(${s.toFixed(2)}) contribution % by gap`);
  gdBuildLegend(gaps.slice(0,16));
}

function gdDrawDist(w, h){
  const {gaps, gapFamilies} = gdData;
  if(!gaps.length) return;
  const p=gPad(), pw=w-p.l-p.r, ph=h-p.t-p.b;
  const ctx=gdCtx;
  const counts=gaps.map(g=>gapFamilies[g]?.length||0);
  const maxC=Math.max(...counts);
  const barW=pw/gaps.length;
  gaps.forEach((g,i)=>{
    const c=counts[i], bh=c/maxC*ph;
    const x=p.l+i*barW, y=p.t+ph-bh;
    const col=gapColor(g,i);
    const isSel=selectedGaps.has(g);
    ctx.fillStyle=col+(isSel?'bb':'33'); ctx.fillRect(x+1,y,barW-2,bh);
    ctx.strokeStyle=col; ctx.lineWidth=isSel?2.5:1.2; ctx.strokeRect(x+1,y,barW-2,bh);
    if(barW>18){ ctx.fillStyle=col; ctx.textAlign='center';
      ctx.font=`${Math.max(7,w*.018)}px JetBrains Mono,monospace`;
      ctx.fillText(''+g, x+barW/2, p.t+ph+16); }
  });
  [0,.25,.5,.75,1].forEach(frac=>{ const y=p.t+ph-frac*ph, v=Math.round(frac*maxC);
    ctx.strokeStyle='#182018'; ctx.lineWidth=0.5;
    ctx.beginPath(); ctx.moveTo(p.l,y); ctx.lineTo(w-p.r,y); ctx.stroke();
    ctx.fillStyle='#3a7040'; ctx.textAlign='right'; ctx.textBaseline='middle';
    ctx.font=`${Math.max(7,w*.018)}px JetBrains Mono,monospace`;
    ctx.fillText(v>=1e6?(v/1e6).toFixed(1)+'M':v>=1e3?(v/1e3).toFixed(0)+'k':v, p.l-4, y);
  });
  gdTitle(ctx, w, `Prime count per gap family`);
  gdBuildLegend(gaps.slice(0,16));
}

function gdDrawConv(w, h){
  const {conv, target, s} = gdData;
  if(conv.length<2) return;
  const p=gPad(), pw=w-p.l-p.r, ph=h-p.t-p.b;
  const ctx=gdCtx;
  const vals=conv.map(d=>d.value);
  const minV=Math.min(target*0.8,...vals), maxV=Math.max(target*1.1,...vals);
  const xS=pw/(conv.length-1), yS=ph/(maxV-minV);
  ctx.font=`${Math.max(7,w*.018)}px JetBrains Mono,monospace`;
  const ty=p.t+ph-(target-minV)*yS;
  ctx.strokeStyle='#ffd70066'; ctx.lineWidth=1; ctx.setLineDash([6,4]);
  ctx.beginPath(); ctx.moveTo(p.l,ty); ctx.lineTo(w-p.r,ty); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle='#ffd700'; ctx.textAlign='right';
  ctx.fillText(`Î¶(${s})=${target.toFixed(6)}`, w-p.r-2, ty-5);
  ctx.strokeStyle='#ff3db4'; ctx.lineWidth=2;
  ctx.shadowColor='#ff3db4'; ctx.shadowBlur=6;
  ctx.beginPath();
  conv.forEach((d,i)=>{ const x=p.l+i*xS, y=p.t+ph-(d.value-minV)*yS; i===0?ctx.moveTo(x,y):ctx.lineTo(x,y); });
  ctx.stroke(); ctx.shadowBlur=0;
  for(let i=0;i<=5;i++){ const frac=i/5, v=minV+frac*(maxV-minV), y=p.t+ph-frac*ph;
    ctx.strokeStyle='#182018'; ctx.lineWidth=0.5;
    ctx.beginPath(); ctx.moveTo(p.l,y); ctx.lineTo(w-p.r,y); ctx.stroke();
    ctx.fillStyle='#3a7040'; ctx.textAlign='right'; ctx.textBaseline='middle';
    ctx.fillText(v.toFixed(4), p.l-4, y);
  }
  ctx.fillStyle='#88cc88'; ctx.textAlign='center';
  const step=Math.max(1,Math.floor(conv.length/8));
  conv.forEach((d,i)=>{ if(i%step===0){ ctx.fillText('g'+d.gap,p.l+i*xS,p.t+ph+18); }});
  gdTitle(ctx, w, `Cumulative Euler product â†’ Î¶(${s.toFixed(2)})`);
  gdBuildLegend([]);
}

function gdDrawRatio(w, h){
  const {c2, c4, c6} = gdData;
  const p=gPad(), pw=w-p.l-p.r, ph=h-p.t-p.b;
  const ctx=gdCtx;
  ctx.font=`${Math.max(8,w*.02)}px JetBrains Mono,monospace`;
  const pairs=[
    {lbl:'gâ‚‚/gâ‚„\ntwin/cousin', val:c4>0?c2/c4:null, tgt:1.0, col:'#ffd700', note:'HLâ†’1'},
    {lbl:'gâ‚‚/gâ‚†\ntwin/sexy',   val:c6>0?c2/c6:null, tgt:0.5, col:'#ff3db4', note:'HLâ†’0.5'},
    {lbl:'gâ‚„/gâ‚†\ncousin/sexy', val:c6>0?c4/c6:null, tgt:0.5, col:'#4ecdc4', note:'HLâ†’0.5'},
  ];
  const bW=(pw/pairs.length)-14, maxV=3;
  pairs.forEach((pair,i)=>{
    const x=p.l+i*(pw/pairs.length)+7;
    if(pair.val===null){ ctx.fillStyle='#555'; ctx.textAlign='center'; ctx.fillText('N/A',x+bW/2,p.t+ph/2); return; }
    const bh=Math.min(pair.val/maxV,1)*ph, y=p.t+ph-bh;
    ctx.fillStyle=pair.col+'33'; ctx.fillRect(x,y,bW,bh);
    ctx.strokeStyle=pair.col; ctx.lineWidth=2; ctx.strokeRect(x,y,bW,bh);
    const ty=p.t+ph-(pair.tgt/maxV)*ph;
    ctx.strokeStyle=pair.col+'99'; ctx.lineWidth=1; ctx.setLineDash([4,3]);
    ctx.beginPath(); ctx.moveTo(x-4,ty); ctx.lineTo(x+bW+4,ty); ctx.stroke(); ctx.setLineDash([]);
    ctx.fillStyle=pair.col; ctx.textAlign='center';
    ctx.fillText(pair.val.toFixed(5),x+bW/2,y-6);
    ctx.fillStyle=pair.col+'99'; ctx.fillText(pair.note,x+bW/2,ty-6);
    ctx.fillStyle='#88cc88';
    pair.lbl.split('\n').forEach((ln,li)=>ctx.fillText(ln,x+bW/2,p.t+ph+16+li*12));
  });
  [0,1,2,3].forEach(v=>{ if(v<=maxV){ const y=p.t+ph-(v/maxV)*ph;
    ctx.strokeStyle='#182018'; ctx.lineWidth=0.5;
    ctx.beginPath(); ctx.moveTo(p.l,y); ctx.lineTo(w-p.r,y); ctx.stroke();
    ctx.fillStyle='#3a7040'; ctx.textAlign='right'; ctx.textBaseline='middle'; ctx.fillText(v, p.l-4, y);
  }});
  gdTitle(ctx, w, `Gap count ratios vs Hardyâ€“Littlewood`);
  gdBuildLegend([]);
}

function gdDrawPct(w, h){
  const {gaps, gapProducts, totalLog, s} = gdData;
  if(!gaps.length) return;
  const p=gPad(), pw=w-p.l-p.r, ph=h-p.t-p.b;
  const ctx=gdCtx;
  const sorted=gaps.filter(g=>gapProducts[g])
    .map((g,i)=>({g, share:gapProducts[g].logProduct/totalLog, i}))
    .sort((a,b)=>b.share-a.share);
  let y=p.t;
  sorted.forEach(({g,share,i})=>{
    const bh=share*ph, col=gapColor(g,i), isSel=selectedGaps.has(g);
    ctx.fillStyle=col+(isSel?'cc':'66'); ctx.fillRect(p.l,y,pw*0.35,bh);
    ctx.strokeStyle=col; ctx.lineWidth=isSel?2:1; ctx.strokeRect(p.l,y,pw*0.35,bh);
    if(bh>10){
      ctx.fillStyle='#fff'; ctx.globalAlpha=0.85; ctx.textAlign='left'; ctx.textBaseline='middle';
      ctx.font=`${Math.max(7,w*.017)}px JetBrains Mono,monospace`;
      ctx.fillText(`g=${g}  ${(share*100).toFixed(2)}%`, p.l+pw*0.35+8, y+bh/2);
      ctx.globalAlpha=1;
    }
    y+=bh;
  });
  gdTitle(ctx, w, `% share of log-Î¶(${s.toFixed(2)}) by gap class`);
  gdBuildLegend(sorted.slice(0,12).map(({g})=>g));
}

function gdBuildLegend(gapList){
  const el=document.getElementById('gdLegend');
  el.innerHTML=gapList.map((g,i)=>{
    const col=gapColor(g,i);
    const isSel=selectedGaps.has(g);
    return `<div class="gap-leg" style="${isSel?'font-weight:700;':''}" onclick="toggleGapChipByVal(${g})" style="cursor:pointer">
      <div class="gap-leg-sw" style="background:${col};${isSel?'outline:2px solid '+col:''}"></div>
      gap ${g}${isSel?' âœ“':''}
    </div>`;
  }).join('');
}

function toggleGapChipByVal(g){
  const chip = document.querySelector(`.gap-chip[data-gap="${g}"]`);
  if(chip){ const i = gapIndexMap[g]||0; toggleGapChip(g, i, chip, gapColor(g,i)); gdDraw(); }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EXPORTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function gdExport4K(){
  if(!gdData) return;
  const SIZE_W=3840, SIZE_H=2160;
  const cv=document.createElement('canvas');
  cv.width=SIZE_W; cv.height=SIZE_H;
  const ctx=cv.getContext('2d');
  ctx.fillStyle='#060608'; ctx.fillRect(0,0,SIZE_W,SIZE_H);
  const origW=gdCanvas.width, origH=gdCanvas.height;
  gdCanvas.width=SIZE_W; gdCanvas.height=SIZE_H;
  gdDraw();
  ctx.drawImage(gdCanvas,0,0);
  gdCanvas.width=origW; gdCanvas.height=origH; gdResizeCanvas();
  ctx.fillStyle='rgba(6,6,8,0.75)'; ctx.fillRect(0,0,SIZE_W,110);
  ctx.fillStyle='#ffd700'; ctx.font='bold 56px JetBrains Mono,monospace';
  ctx.textAlign='left'; ctx.textBaseline='top';
  ctx.fillText(`Gap Decomp Â· Î¶(${gdData.s.toFixed(2)}) Â· N=${gdData.maxN.toLocaleString()}`, 60, 20);
  ctx.fillStyle='#88cc88'; ctx.font='32px JetBrains Mono,monospace';
  ctx.fillText(`${gdData.primes.length.toLocaleString()} primes Â· ${gdData.gaps.length} families Â· err=${(gdData.finalError*100).toFixed(8)}%`, 60, 78);
  ctx.fillStyle='rgba(255,61,180,0.5)'; ctx.font='28px JetBrains Mono,monospace';
  ctx.textAlign='right'; ctx.fillText('Wessen Getachew Â· @7dview', SIZE_W-60, 78);
  const link=document.createElement('a');
  link.download=`gap_decomp_4K_N${gdData.maxN}_s${gdData.s.toFixed(2)}_${gdTab}.png`;
  link.href=cv.toDataURL('image/png'); link.click();
  gdDraw();
}

function gdExportCSV(){
  if(!gdData) return;
  const d=gdData;
  let csv='Gap,Count,PctPrimes,Product,LogProduct,LogShare(%),CumulativeProduct,RelativeError,AbsoluteError\n';
  let cum=1;
  d.gaps.forEach(g=>{
    const gp=d.gapProducts[g]; if(!gp) return;
    cum*=gp.product;
    const logShare=(gp.logProduct/(d.totalLog||1)*100).toFixed(10);
    const relErr=Math.abs(cum-d.target)/d.target;
    const abErr=Math.abs(cum-d.target);
    const pctPrimes=(gp.count/(d.primes.length||1)*100).toFixed(10);
    csv+=`${g},${gp.count},${pctPrimes},${gp.product.toFixed(15)},${gp.logProduct.toFixed(15)},${logShare},${cum.toFixed(15)},${relErr.toFixed(15)},${abErr.toFixed(15)}\n`;
  });
  csvDownload(csv, `gap_decomp_N${d.maxN}_s${d.s.toFixed(2)}.csv`);
}

function gdExportTXT(){
  if(!gdData) return;
  const d=gdData, now=new Date().toISOString();
  const pi_str=d.pi_calc?`Calculated Ï€  = ${d.pi_calc.toFixed(15)}  (|err|=${Math.abs(d.pi_calc-Math.PI).toExponential(6)})`:'Ï€: only valid at s=2';
  let txt=`
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  PRIME GAP DECOMPOSITION REPORT â€” Î¶(s) Euler Analysis
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Generated : ${now}  |  Author: Wessen Getachew Â· @7dview

PARAMETERS
  Max N         = ${d.maxN.toLocaleString()}
  Exponent s    = ${d.s.toFixed(4)}
  Gap filter    = ${gdFilter}

PRIME STATISTICS
  Total primes  = ${d.primes.length.toLocaleString()}
  Max prime     = ${d.primes[d.primes.length-1].toLocaleString()}
  Gap families  = ${d.gaps.length}
  Largest gap   = ${Math.max(...d.gaps)}
  Most common g = ${d.mostCommon} (${d.mcCount.toLocaleString()} times)

TWIN / COUSIN / SEXY
  Gap 2 (twin)  = ${d.c2.toLocaleString()}
  Gap 4 (cousin)= ${d.c4.toLocaleString()}
  Gap 6 (sexy)  = ${d.c6.toLocaleString()}
  g2/g4 ratio   = ${d.c4>0?(d.c2/d.c4).toFixed(12):'N/A'}  [HL: 1.0]
  g2/g6 ratio   = ${d.c6>0?(d.c2/d.c6).toFixed(12):'N/A'}  [HL: 0.5]
  g4/g6 ratio   = ${d.c6>0?(d.c4/d.c6).toFixed(12):'N/A'}  [HL: 0.5]

ZETA PRODUCT
  Target Î¶(${d.s.toFixed(2)}) = ${d.target.toFixed(15)}
  Computed      = ${d.finalProduct.toFixed(15)}
  Abs error     = ${Math.abs(d.finalProduct-d.target).toExponential(10)}
  Rel error     = ${(d.finalError*100).toFixed(12)}%
  ${pi_str}

GAP CLASS TABLE
${'Gap'.padEnd(8)}${'Count'.padEnd(14)}${'Pct%'.padEnd(12)}${'Product'.padEnd(22)}${'LogProd'.padEnd(22)}${'log-Î¶%'.padEnd(16)}${'Cumulative'.padEnd(22)}RelErr%
${'â”€'.repeat(120)}
`;
  let cum=1;
  d.gaps.forEach(g=>{
    const gp=d.gapProducts[g]; if(!gp) return;
    cum*=gp.product;
    const relErr=Math.abs(cum-d.target)/d.target*100;
    const logShare=gp.logProduct/(d.totalLog||1)*100;
    const pct=gp.count/(d.primes.length||1)*100;
    txt+=`${(''+g).padEnd(8)}${gp.count.toString().padEnd(14)}${pct.toFixed(6).padEnd(12)}${gp.product.toFixed(12).padEnd(22)}${gp.logProduct.toFixed(12).padEnd(22)}${logShare.toFixed(6).padEnd(16)}${cum.toFixed(12).padEnd(22)}${relErr.toFixed(10)}\n`;
  });
  txt+=`\n${'â•'.repeat(60)}\n`;
  const blob=new Blob([txt],{type:'text/plain'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob); a.download=`gap_decomp_report_N${d.maxN}_s${d.s.toFixed(2)}.txt`;
  a.click();
}

function csvDownload(csv, filename){
  const blob=new Blob([csv],{type:'text/csv'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob); a.download=filename; a.click();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  HARMONICS MODULE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Farey harmonic intervals: {ratio, name, p, q} where ratio=p/q
const HARM_INTERVALS = [
  { name:'1:1',   p:1,  q:1,  cents:0 },
  { name:'16:15', p:16, q:15, cents:112 },
  { name:'9:8',   p:9,  q:8,  cents:204 },
  { name:'6:5',   p:6,  q:5,  cents:316 },
  { name:'5:4',   p:5,  q:4,  cents:386 },
  { name:'4:3',   p:4,  q:3,  cents:498 },
  { name:'45:32', p:45, q:32, cents:590 },
  { name:'3:2',   p:3,  q:2,  cents:702 },
  { name:'8:5',   p:8,  q:5,  cents:814 },
  { name:'5:3',   p:5,  q:3,  cents:884 },
  { name:'9:5',   p:9,  q:5,  cents:1018 },
  { name:'15:8',  p:15, q:8,  cents:1088 },
  { name:'2:1',   p:2,  q:1,  cents:1200 },
  { name:'5:2',   p:5,  q:2,  cents:1586 },
  { name:'3:1',   p:3,  q:1,  cents:1902 },
  { name:'4:1',   p:4,  q:1,  cents:2400 },
];

function harmConsonanceColor(p, q){
  const tenney = p * q;
  if(p===1&&q===1) return '#22c55e';
  if(tenney<=4) return '#60a5fa';
  if(tenney<=16) return '#ffd700';
  if(tenney<=64) return '#f97316';
  return '#a855f7';
}

let harmSelectedIntervals = new Set(); // indices into HARM_INTERVALS
let harmColorMode = false;
let harmArnoldK = 0;
let harmBaseArnold = 0; // store original to reset

let audioCtx = null;
let harmOscillators = [];

function harmGetCtx(){
  if(!audioCtx) audioCtx = new(window.AudioContext||window.webkitAudioContext)();
  if(audioCtx.state==='suspended') audioCtx.resume();
  return audioCtx;
}

function harmStop(){
  harmOscillators.forEach(o=>{ try{o.stop();}catch(e){} });
  harmOscillators=[];
  ['harmPlayBtn','harmChordBtn','harmArpBtn'].forEach(id=>document.getElementById(id)?.classList.remove('on'));
}

function harmGetBaseHz(){ return parseFloat(document.getElementById('harmBaseHz').value)||220; }
function harmGetVol(){ return parseFloat(document.getElementById('harmVol').value)||0.35; }
function harmGetWave(){ return document.getElementById('harmWave').value||'sine'; }

function harmPlayFreq(hz, duration=1.5){
  const ctx=harmGetCtx();
  const osc=ctx.createOscillator();
  const gain=ctx.createGain();
  osc.connect(gain); gain.connect(ctx.destination);
  osc.type=harmGetWave(); osc.frequency.value=hz;
  const vol=harmGetVol();
  gain.gain.setValueAtTime(vol, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+duration);
  osc.start(); osc.stop(ctx.currentTime+duration);
  harmOscillators.push(osc);
  return osc;
}

function harmPlay(){
  harmStop();
  const base=harmGetBaseHz();
  const sel=[...harmSelectedIntervals];
  if(!sel.length){ harmPlayFreq(base); return; }
  const iv=HARM_INTERVALS[sel[sel.length-1]];
  harmPlayFreq(base * iv.p / iv.q);
  document.getElementById('harmPlayBtn').classList.add('on');
}

function harmChord(){
  harmStop();
  const base=harmGetBaseHz();
  const sel=[...harmSelectedIntervals];
  if(!sel.length) sel.push(0);
  sel.forEach(idx=>{
    const iv=HARM_INTERVALS[idx];
    harmPlayFreq(base*iv.p/iv.q, 2.0);
  });
  document.getElementById('harmChordBtn').classList.add('on');
}

function harmArp(){
  harmStop();
  const base=harmGetBaseHz();
  const sel=[...harmSelectedIntervals];
  if(!sel.length) sel.push(0);
  const ctx=harmGetCtx();
  sel.forEach((idx,i)=>{
    const iv=HARM_INTERVALS[idx];
    const hz=base*iv.p/iv.q;
    const osc=ctx.createOscillator();
    const gain=ctx.createGain();
    osc.connect(gain); gain.connect(ctx.destination);
    osc.type=harmGetWave(); osc.frequency.value=hz;
    const t=ctx.currentTime+i*0.35;
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(harmGetVol(), t+0.05);
    gain.gain.exponentialRampToValueAtTime(0.0001, t+0.6);
    osc.start(t); osc.stop(t+0.65);
    harmOscillators.push(osc);
  });
  document.getElementById('harmArpBtn').classList.add('on');
}

function noteFromHz(hz){
  const notes=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const n=Math.round(12*Math.log2(hz/440))+69;
  if(n<0||n>127) return 'â€”';
  return notes[n%12]+(Math.floor(n/12)-1);
}

function buildHarmIntervalGrid(){
  const grid=document.getElementById('harmIntervalGrid');
  grid.innerHTML='';
  HARM_INTERVALS.forEach((iv,i)=>{
    const col=harmConsonanceColor(iv.p,iv.q);
    const btn=document.createElement('button');
    btn.className='harm-interval-btn';
    btn.style.borderColor=col+'55';
    btn.style.color=col+'aa';
    btn.innerHTML=iv.name;
    btn.title=`${iv.name} Â· ${iv.cents}Â¢ Â· Tenney height: ${iv.p*iv.q}`;
    btn.onclick=()=>toggleHarmInterval(i,btn,iv,col);
    grid.appendChild(btn);
  });
}

function toggleHarmInterval(i, btn, iv, col){
  if(harmSelectedIntervals.has(i)){
    harmSelectedIntervals.delete(i);
    btn.classList.remove('active');
    btn.style.background='';
    btn.style.color=col+'aa';
  } else {
    harmSelectedIntervals.add(i);
    btn.classList.add('active');
    btn.style.background=col;
    btn.style.color='#000';
  }
  updateHarmDisplay();
  if(harmColorMode) precompute(); // recolor sphere
}

function updateHarmDisplay(){
  const sel=[...harmSelectedIntervals];
  if(!sel.length){
    document.getElementById('harmFreqDisplay').textContent='â€” Hz';
    document.getElementById('harmNoteDisplay').textContent='â€” Â· â€”';
    return;
  }
  const last=HARM_INTERVALS[sel[sel.length-1]];
  const base=harmGetBaseHz();
  const hz=base*last.p/last.q;
  document.getElementById('harmFreqDisplay').textContent=hz.toFixed(2)+' Hz';
  document.getElementById('harmNoteDisplay').textContent=last.name+' Â· '+noteFromHz(hz);
}

// Arnold tongue warp: perturb the sphere rendering with KÂ·sin(2Ï€Â·ratio)
function applyArnoldWarp(){
  harmArnoldK=parseFloat(document.getElementById('harmArnold').value)||0;
  precompute(); // rebuilds precomputed with warp applied
}
function resetArnold(){
  harmArnoldK=0;
  document.getElementById('harmArnold').value=0;
  document.getElementById('harmArnoldVal').textContent='0.00';
  precompute();
}

// Harmonic color mode: sphere hue based on consonance of selected intervals
// The trail hue cycles through the consonance colors of selected intervals
function harmColorForProgress(frac){
  const sel=[...harmSelectedIntervals];
  if(!sel.length) return null;
  // Cycle through selected intervals by position on curve
  const idx=Math.floor(frac*sel.length)%sel.length;
  const iv=HARM_INTERVALS[sel[idx]];
  return harmConsonanceColor(iv.p,iv.q);
}

// Hook into precompute to apply Arnold warp if K>0
const _origPrecompute = precompute;
// We'll re-override toSphere to apply warp
const _origToSphere = toSphere;

function toSphereWarped(t, r){
  let lon = t;
  if(harmArnoldK > 0){
    // Arnold circle map perturbation: lon += KÂ·sin(2Ï€Â·lon/(2Ï€))
    lon = t + harmArnoldK * Math.sin(t);
  }
  const polar = (t / thetaTotal) * Math.PI;
  const rn = r / (A + 1.2);
  const x = rn * Math.sin(polar) * Math.cos(lon);
  const y = rn * Math.cos(polar);
  const z = rn * Math.sin(polar) * Math.sin(lon);
  return [x, y, z];
}

// Patch toSphere globally
// (call toSphereWarped from precompute instead of toSphere)

// Harmonic color panel toggle
document.getElementById('harmHeader').addEventListener('click',()=>{
  const body=document.getElementById('harmBody');
  const chev=document.getElementById('harmChevron');
  const hdr=document.getElementById('harmHeader');
  body.classList.toggle('open');
  chev.classList.toggle('open');
  hdr.classList.toggle('open');
});

document.getElementById('harmColorMode').addEventListener('change',function(){
  harmColorMode=this.checked;
  document.getElementById('harmModeState').textContent=harmColorMode
    ?'on â€” sphere colored by harmonic consonance'
    :'off â€” sphere uses default colors';
  precompute();
});

document.getElementById('harmBaseHz').addEventListener('input',function(){
  document.getElementById('harmBaseHzVal').textContent=this.value+' Hz';
  updateHarmDisplay();
});
document.getElementById('harmVol').addEventListener('input',function(){
  document.getElementById('harmVolVal').textContent=Math.round(this.value*100)+'%';
});
document.getElementById('harmArnold').addEventListener('input',function(){
  document.getElementById('harmArnoldVal').textContent=parseFloat(this.value).toFixed(2);
});

buildHarmIntervalGrid();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
buildPresets();
hardReset();
loop();
</script>
</body>
</html>
