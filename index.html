
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Boundary Cancellation Principle - k-Tuple Lattice Visualizer</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap');

:root {
    --bg-primary: #0a0a0f;
    --bg-secondary: #12121a;
    --bg-tertiary: #1a1a24;
    --bg-panel: #0e0e14;
    --border-subtle: #2a2a3a;
    --border-accent: #3d3d52;
    --text-primary: #e8e8f0;
    --text-secondary: #9898a8;
    --text-muted: #686878;
    --accent-gold: #c9a227;
    --accent-gold-dim: #8a7020;
    --accent-blue: #4a7cb8;
    --accent-cyan: #5aa8a0;
    --accent-red: #b85a5a;
    --accent-green: #5ab85a;
    --point-interior: #2a5a8a;
    --point-boundary: #c9a227;
    --point-coprime: #5ab87a;
    --point-removed: #5a2a2a;
    --grid-line: #1a1a28;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: 'JetBrains Mono', monospace;
    background: var(--bg-primary);
    color: var(--text-primary);
    min-height: 100vh;
    overflow-x: hidden;
}

.app-container {
    display: grid;
    grid-template-columns: 320px 1fr 300px;
    grid-template-rows: auto 1fr auto;
    min-height: 100vh;
    gap: 1px;
    background: var(--border-subtle);
}

header {
    grid-column: 1 / -1;
    background: var(--bg-panel);
    padding: 12px 20px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid var(--border-subtle);
}

.logo {
    font-family: 'Cormorant Garamond', serif;
    font-size: 1.4rem;
    font-weight: 600;
    color: var(--accent-gold);
}

.logo-sub {
    font-size: 0.7rem;
    color: var(--text-muted);
    font-family: 'JetBrains Mono', monospace;
    margin-left: 10px;
}

.header-actions { display: flex; gap: 8px; align-items: center; }

.status-indicator {
    padding: 4px 10px;
    font-size: 0.7rem;
    border-radius: 3px;
    background: var(--bg-tertiary);
    color: var(--text-muted);
}

.status-indicator.computing {
    background: var(--accent-gold-dim);
    color: var(--text-primary);
    animation: pulse 1s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
}

.controls-panel {
    background: var(--bg-panel);
    padding: 16px;
    overflow-y: auto;
    max-height: calc(100vh - 100px);
}

.main-view {
    background: var(--bg-secondary);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.analysis-panel {
    background: var(--bg-panel);
    padding: 16px;
    overflow-y: auto;
    max-height: calc(100vh - 100px);
}

footer {
    grid-column: 1 / -1;
    background: var(--bg-panel);
    padding: 8px 20px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-top: 1px solid var(--border-subtle);
    font-size: 0.65rem;
    color: var(--text-muted);
}

.section { margin-bottom: 20px; }

.section-title {
    font-family: 'Cormorant Garamond', serif;
    font-size: 0.85rem;
    font-weight: 600;
    color: var(--accent-gold);
    text-transform: uppercase;
    letter-spacing: 0.08em;
    margin-bottom: 10px;
    padding-bottom: 5px;
    border-bottom: 1px solid var(--border-subtle);
}

.control-group { margin-bottom: 14px; }

.control-label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.7rem;
    color: var(--text-secondary);
    margin-bottom: 5px;
}

.control-value { color: var(--accent-gold); font-weight: 500; }

input[type="range"] {
    width: 100%;
    height: 4px;
    background: var(--bg-tertiary);
    border-radius: 2px;
    outline: none;
    -webkit-appearance: none;
    cursor: pointer;
}

input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 12px;
    height: 12px;
    background: var(--accent-gold);
    border-radius: 50%;
    cursor: pointer;
}

input[type="number"], input[type="text"] {
    width: 100%;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-subtle);
    color: var(--text-primary);
    padding: 6px 10px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.75rem;
    border-radius: 3px;
    outline: none;
}

input[type="number"]:focus, input[type="text"]:focus {
    border-color: var(--accent-gold);
}

select {
    width: 100%;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-subtle);
    color: var(--text-primary);
    padding: 6px 10px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.75rem;
    border-radius: 3px;
    outline: none;
    cursor: pointer;
}

.btn {
    padding: 6px 12px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    font-weight: 500;
    border: 1px solid var(--border-subtle);
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.15s ease;
    background: var(--bg-tertiary);
    color: var(--text-primary);
}

.btn:hover {
    border-color: var(--accent-gold);
    color: var(--accent-gold);
}

.btn-primary {
    background: var(--accent-gold);
    color: var(--bg-primary);
    border-color: var(--accent-gold);
    font-weight: 600;
}

.btn-primary:hover {
    background: #ddb52f;
    border-color: #ddb52f;
    color: var(--bg-primary);
}

.btn-refresh {
    background: var(--accent-green);
    color: var(--bg-primary);
    border-color: var(--accent-green);
}

.btn-refresh:hover {
    background: #6dc86d;
    border-color: #6dc86d;
}

.btn-group { display: flex; gap: 6px; flex-wrap: wrap; }

.btn-sm { padding: 5px 8px; font-size: 0.65rem; }

.checkbox-group {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: 6px;
}

.checkbox-group input[type="checkbox"] {
    width: 14px;
    height: 14px;
    accent-color: var(--accent-gold);
    cursor: pointer;
}

.checkbox-group label {
    font-size: 0.7rem;
    color: var(--text-secondary);
    cursor: pointer;
}

.canvas-container {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    background: var(--bg-primary);
}

.canvas-wrapper {
    position: relative;
    background: var(--bg-secondary);
    border: 1px solid var(--border-subtle);
    border-radius: 4px;
    overflow: hidden;
    aspect-ratio: 1 / 1;
    max-width: min(100%, calc(100vh - 200px));
    max-height: calc(100vh - 200px);
    width: 100%;
}

.canvas-wrapper canvas {
    width: 100%;
    height: 100%;
    display: block;
}

.canvas-label {
    position: absolute;
    top: 8px;
    left: 8px;
    font-size: 0.65rem;
    color: var(--text-muted);
    background: rgba(10, 10, 15, 0.9);
    padding: 3px 6px;
    border-radius: 2px;
}

.canvas-stats {
    position: absolute;
    bottom: 8px;
    right: 8px;
    font-size: 0.6rem;
    color: var(--text-muted);
    background: rgba(10, 10, 15, 0.9);
    padding: 4px 8px;
    border-radius: 2px;
    text-align: right;
    line-height: 1.4;
}

.view-tabs {
    display: flex;
    background: var(--bg-panel);
    border-bottom: 1px solid var(--border-subtle);
    padding: 0 10px;
}

.view-tab {
    padding: 10px 16px;
    font-size: 0.7rem;
    color: var(--text-muted);
    cursor: pointer;
    border-bottom: 2px solid transparent;
    transition: all 0.15s ease;
}

.view-tab:hover { color: var(--text-secondary); }

.view-tab.active {
    color: var(--accent-gold);
    border-bottom-color: var(--accent-gold);
}

.stat-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 0;
    border-bottom: 1px solid var(--border-subtle);
    font-size: 0.7rem;
}

.stat-row:last-child { border-bottom: none; }

.stat-label { color: var(--text-secondary); }

.stat-value { color: var(--text-primary); font-weight: 500; }

.stat-value.highlight { color: var(--accent-gold); }

.formula-box {
    background: var(--bg-tertiary);
    border: 1px solid var(--border-subtle);
    border-radius: 3px;
    padding: 10px;
    margin-top: 6px;
    font-size: 0.75rem;
    color: var(--text-secondary);
    font-family: 'Cormorant Garamond', serif;
    font-style: italic;
}

.formula-main {
    color: var(--text-primary);
    font-size: 0.9rem;
    margin-bottom: 6px;
}

.legend { display: flex; flex-direction: column; gap: 5px; margin-top: 10px; }

.legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.65rem;
    color: var(--text-secondary);
}

.legend-color { width: 10px; height: 10px; border-radius: 2px; }

.dimension-selector {
    display: flex;
    gap: 4px;
    margin-bottom: 10px;
    flex-wrap: wrap;
}

.dim-btn {
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-subtle);
    border-radius: 3px;
    color: var(--text-secondary);
    cursor: pointer;
    font-size: 0.75rem;
    transition: all 0.15s ease;
}

.dim-btn:hover {
    border-color: var(--accent-gold);
    color: var(--accent-gold);
}

.dim-btn.active {
    background: var(--accent-gold);
    border-color: var(--accent-gold);
    color: var(--bg-primary);
}

.export-section {
    background: var(--bg-tertiary);
    border: 1px solid var(--border-subtle);
    border-radius: 3px;
    padding: 10px;
    margin-top: 10px;
}

.export-title {
    font-size: 0.7rem;
    color: var(--text-secondary);
    margin-bottom: 8px;
}

.export-options {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 6px;
}

.tuple-preview {
    font-size: 0.65rem;
    color: var(--text-muted);
    margin-top: 6px;
    padding: 6px;
    background: var(--bg-tertiary);
    border-radius: 3px;
}

.progress-bar {
    width: 100%;
    height: 3px;
    background: var(--bg-tertiary);
    border-radius: 2px;
    overflow: hidden;
    margin-top: 6px;
}

.progress-fill {
    height: 100%;
    background: var(--accent-gold);
    transition: width 0.2s ease;
}

.hidden-canvas {
    position: absolute;
    left: -9999px;
    top: -9999px;
}

.modal-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0, 0, 0, 0.85);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 2000;
}

.modal-overlay.visible { display: flex; }

.modal {
    background: var(--bg-panel);
    border: 1px solid var(--border-subtle);
    border-radius: 6px;
    padding: 20px;
    max-width: 450px;
    width: 90%;
}

.modal-title {
    font-family: 'Cormorant Garamond', serif;
    font-size: 1.1rem;
    color: var(--accent-gold);
    margin-bottom: 12px;
}

.modal-content {
    font-size: 0.75rem;
    color: var(--text-secondary);
    line-height: 1.5;
}

.modal-actions {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
    margin-top: 16px;
}

.loading-overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(10, 10, 15, 0.8);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 100;
}

.loading-overlay.visible { display: flex; }

.loading-spinner {
    width: 40px;
    height: 40px;
    border: 3px solid var(--border-subtle);
    border-top-color: var(--accent-gold);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

::-webkit-scrollbar { width: 5px; height: 5px; }
::-webkit-scrollbar-track { background: var(--bg-secondary); }
::-webkit-scrollbar-thumb { background: var(--border-accent); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: var(--accent-gold-dim); }
</style>
</head>
<body>

<div class="app-container">
    <header>
        <div>
            <span class="logo">Boundary Cancellation Principle</span>
            <span class="logo-sub">k-Tuple Lattice Visualizer</span>
        </div>
        <div class="header-actions">
            <span class="status-indicator" id="statusIndicator">Ready</span>
            <button class="btn" onclick="showHelp()">Help</button>
            <button class="btn btn-refresh" onclick="compute()">Refresh</button>
        </div>
    </header>

    <aside class="controls-panel">
        <div class="section">
            <div class="section-title">Lattice Structure</div>
            
            <div class="control-group">
                <div class="control-label"><span>Structure Type</span></div>
                <select id="structureType" onchange="updateStructure()">
                    <option value="coprime">Coprime Lattice Points</option>
                    <option value="squarefree">Squarefree Integers</option>
                    <option value="kfree">k-Free Integers</option>
                    <option value="coprime-tuple">Coprime m-Tuples</option>
                    <option value="prime-ktuple">Prime k-Tuple Sieve</option>
                    <option value="custom">Custom Admissible Tuple</option>
                </select>
            </div>

            <div class="control-group">
                <div class="control-label"><span>Dimension (k)</span></div>
                <div class="dimension-selector">
                    <button class="dim-btn active" data-dim="2" onclick="setDimension(2)">2</button>
                    <button class="dim-btn" data-dim="3" onclick="setDimension(3)">3</button>
                    <button class="dim-btn" data-dim="4" onclick="setDimension(4)">4</button>
                    <button class="dim-btn" data-dim="5" onclick="setDimension(5)">5</button>
                    <button class="dim-btn" data-dim="6" onclick="setDimension(6)">6</button>
                </div>
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>Radius / Bound (R)</span>
                    <span class="control-value" id="radiusValue">30</span>
                </div>
                <input type="range" id="radius" min="10" max="200" value="30" oninput="updateRadius()">
            </div>

            <div class="control-group" id="kfreeParam" style="display:none">
                <div class="control-label">
                    <span>k-free parameter</span>
                    <span class="control-value" id="kfreeValue">2</span>
                </div>
                <input type="range" id="kfree" min="2" max="10" value="2" oninput="updateKfree()">
            </div>
        </div>

        <div class="section" id="tupleSection" style="display:none">
            <div class="section-title">Admissible Tuple</div>
            <div class="control-group">
                <div class="control-label"><span>Offsets (comma-separated)</span></div>
                <input type="text" id="tupleOffsets" value="0,2,6,8">
                <div class="tuple-preview" id="tuplePreview">Pattern: (n, n+2, n+6, n+8)</div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Visualization</div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="showGrid" checked>
                <label for="showGrid">Show grid lines</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="showBoundary" checked>
                <label for="showBoundary">Highlight boundary</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="showRemoved">
                <label for="showRemoved">Show removed points</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="showAxes" checked>
                <label for="showAxes">Show axes</label>
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>Point Size</span>
                    <span class="control-value" id="pointSizeValue">4</span>
                </div>
                <input type="range" id="pointSize" min="1" max="12" value="4" oninput="updatePointSize()">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>Boundary Thickness</span>
                    <span class="control-value" id="boundaryThickValue">3</span>
                </div>
                <input type="range" id="boundaryThick" min="1" max="15" value="3" oninput="updateBoundaryThick()">
            </div>
        </div>

        <div class="section">
            <div class="section-title">3D Rotation</div>
            
            <div class="control-group">
                <div class="control-label">
                    <span>Rotation X</span>
                    <span class="control-value" id="rotXValue">25</span>
                </div>
                <input type="range" id="rotX" min="0" max="360" value="25" oninput="updateRotation()">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>Rotation Y</span>
                    <span class="control-value" id="rotYValue">35</span>
                </div>
                <input type="range" id="rotY" min="0" max="360" value="35" oninput="updateRotation()">
            </div>

            <div class="btn-group">
                <button class="btn btn-sm" onclick="resetRotation()">Reset</button>
                <button class="btn btn-sm" id="animateBtn" onclick="toggleAnimation()">Animate</button>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Export</div>
            
            <div class="export-section">
                <div class="export-title">4K PNG Export</div>
                <div class="export-options">
                    <button class="btn btn-sm" onclick="exportPNG('current')">Current View</button>
                    <button class="btn btn-sm" onclick="exportPNG('all')">All Views</button>
                </div>
            </div>

            <div class="export-section">
                <div class="export-title">CSV Data Export</div>
                <div class="export-options">
                    <button class="btn btn-sm" onclick="exportCSV('points')">Lattice Points</button>
                    <button class="btn btn-sm" onclick="exportCSV('stats')">Statistics</button>
                    <button class="btn btn-sm" onclick="exportCSV('error')">Error Data</button>
                    <button class="btn btn-sm" onclick="exportCSV('all')">Full Export</button>
                </div>
            </div>
        </div>
    </aside>

    <main class="main-view">
        <div class="view-tabs">
            <div class="view-tab active" data-view="lattice" onclick="setView('lattice')">Lattice</div>
            <div class="view-tab" data-view="boundary" onclick="setView('boundary')">Boundary</div>
            <div class="view-tab" data-view="density" onclick="setView('density')">Density</div>
            <div class="view-tab" data-view="error" onclick="setView('error')">Error</div>
        </div>

        <div class="canvas-container">
            <div class="canvas-wrapper" id="canvasWrapper">
                <canvas id="mainCanvas"></canvas>
                <div class="canvas-label" id="canvasLabel">Lattice Structure</div>
                <div class="canvas-stats" id="canvasStats"></div>
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="loading-spinner"></div>
                </div>
            </div>
        </div>
    </main>

    <aside class="analysis-panel">
        <div class="section">
            <div class="section-title">Configuration</div>
            <div class="stat-row">
                <span class="stat-label">Structure</span>
                <span class="stat-value" id="statStructure">Coprime Lattice</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Dimension</span>
                <span class="stat-value" id="statDimension">2</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Radius</span>
                <span class="stat-value" id="statRadius">30</span>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Counting</div>
            <div class="stat-row">
                <span class="stat-label">Total Points</span>
                <span class="stat-value highlight" id="statTotal">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Surviving</span>
                <span class="stat-value highlight" id="statSurviving">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Removed</span>
                <span class="stat-value" id="statRemoved">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Density</span>
                <span class="stat-value" id="statDensity">0%</span>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Main Term</div>
            <div class="formula-box">
                <div class="formula-main" id="formulaMain">R^k / zeta(k)</div>
                <div id="formulaExplain">Expected count</div>
            </div>
            <div class="stat-row">
                <span class="stat-label">Predicted</span>
                <span class="stat-value highlight" id="statPredicted">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Actual</span>
                <span class="stat-value" id="statActual">0</span>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Error Analysis</div>
            <div class="formula-box">
                <div class="formula-main" id="errorFormula">O(R^(k-1))</div>
                <div id="errorExplain">Boundary scaling</div>
            </div>
            <div class="stat-row">
                <span class="stat-label">Error</span>
                <span class="stat-value highlight" id="statError">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Error Bound</span>
                <span class="stat-value" id="statErrorBound">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Relative Error</span>
                <span class="stat-value" id="statRelError">0%</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="errorProgress" style="width: 0%"></div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Boundary</div>
            <div class="stat-row">
                <span class="stat-label">Boundary Pts</span>
                <span class="stat-value highlight" id="statBoundary">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Interior Pts</span>
                <span class="stat-value" id="statInterior">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Critical Exp</span>
                <span class="stat-value highlight" id="statExponent">1/2</span>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Legend</div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #5ab87a"></div>
                    <span>Surviving (coprime/k-free)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #c9a227"></div>
                    <span>Boundary shell</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #5a2a2a"></div>
                    <span>Removed by sieve</span>
                </div>
            </div>
        </div>
    </aside>

    <footer>
        <span>Boundary Cancellation Principle Visualizer</span>
        <span id="computeTime">-</span>
    </footer>
</div>

<div class="modal-overlay" id="helpModal">
    <div class="modal">
        <div class="modal-title">Boundary Cancellation Principle</div>
        <div class="modal-content">
            <p><strong>Core Principle:</strong> In k-dimensional lattice counting with Mobius inclusion-exclusion, interior contributions cancel efficiently while incomplete cancellation accumulates at the boundary.</p>
            <br>
            <p><strong>Error Exponent:</strong> (k-1)/k determines error scaling. Squarefree (k=2) gives O(x^1/2), cubefree (k=3) gives O(x^1/3).</p>
            <br>
            <p><strong>Usage:</strong> Select structure type, set dimension and radius, then click Refresh to compute. Use tabs to switch views.</p>
        </div>
        <div class="modal-actions">
            <button class="btn btn-primary" onclick="hideHelp()">Close</button>
        </div>
    </div>
</div>

<canvas id="exportCanvas" class="hidden-canvas"></canvas>

<script>
const S = {
    dimension: 2,
    radius: 30,
    structure: 'coprime',
    kfreeParam: 2,
    tupleOffsets: [0, 2, 6, 8],
    rotation: { x: 25, y: 35 },
    pointSize: 4,
    boundaryThickness: 3,
    animating: false,
    currentView: 'lattice',
    points: [],
    classified: [],
    errorData: [],
    primes: [],
    maxPrime: 0
};

function sievePrimes(max) {
    if (max <= S.maxPrime) return;
    const sieve = new Array(max + 1).fill(true);
    sieve[0] = sieve[1] = false;
    for (let i = 2; i * i <= max; i++) {
        if (sieve[i]) {
            for (let j = i * i; j <= max; j += i) sieve[j] = false;
        }
    }
    S.primes = [];
    for (let i = 2; i <= max; i++) {
        if (sieve[i]) S.primes.push(i);
    }
    S.maxPrime = max;
}

function gcd(a, b) {
    a = Math.abs(a); b = Math.abs(b);
    while (b) [a, b] = [b, a % b];
    return a;
}

function gcdArr(arr) {
    return arr.reduce((a, b) => gcd(a, b));
}

function isKFree(n, k) {
    if (n <= 0) return false;
    sievePrimes(Math.ceil(Math.pow(n, 1/k)) + 10);
    for (const p of S.primes) {
        const pk = Math.pow(p, k);
        if (pk > n) break;
        if (n % pk === 0) return false;
    }
    return true;
}

function isPrime(n) {
    if (n < 2) return false;
    if (n === 2) return true;
    if (n % 2 === 0) return false;
    sievePrimes(Math.ceil(Math.sqrt(n)) + 10);
    for (const p of S.primes) {
        if (p * p > n) return true;
        if (n % p === 0) return false;
    }
    return true;
}

function generatePoints() {
    const R = S.radius;
    const k = S.dimension;
    const points = [];
    const R2 = R * R;
    
    if (k === 2) {
        for (let x = 1; x <= R; x++) {
            const maxY = Math.floor(Math.sqrt(R2 - x * x));
            for (let y = -maxY; y <= maxY; y++) {
                if (x * x + y * y <= R2) points.push([x, y]);
            }
        }
    } else if (k === 3) {
        for (let x = 1; x <= R; x++) {
            const rem1 = R2 - x * x;
            if (rem1 < 0) continue;
            const maxY = Math.floor(Math.sqrt(rem1));
            for (let y = -maxY; y <= maxY; y++) {
                const rem2 = rem1 - y * y;
                if (rem2 < 0) continue;
                const maxZ = Math.floor(Math.sqrt(rem2));
                for (let z = -maxZ; z <= maxZ; z++) {
                    points.push([x, y, z]);
                }
            }
        }
    } else {
        const generate = (current, depth, remaining) => {
            if (depth === k) {
                points.push([...current]);
                return;
            }
            const max = Math.floor(Math.sqrt(remaining));
            const start = depth === 0 ? 1 : -max;
            for (let v = start; v <= max; v++) {
                const newRem = remaining - v * v;
                if (newRem >= 0) {
                    current.push(v);
                    generate(current, depth + 1, newRem);
                    current.pop();
                }
            }
        };
        generate([], 0, R2);
    }
    
    return points;
}

function filterPoints(points) {
    return points.map(p => {
        let survives = false;
        
        switch (S.structure) {
            case 'coprime':
            case 'coprime-tuple':
                survives = gcdArr(p.map(Math.abs)) === 1;
                break;
            case 'squarefree':
                const n2 = p.reduce((s, x) => s + x * x, 0);
                survives = isKFree(Math.round(Math.sqrt(n2)), 2);
                break;
            case 'kfree':
                const nk = p.reduce((s, x) => s + x * x, 0);
                survives = isKFree(Math.round(Math.sqrt(nk)), S.kfreeParam);
                break;
            case 'prime-ktuple':
            case 'custom':
                const base = Math.abs(p[0]);
                survives = S.tupleOffsets.every(off => isPrime(base + off));
                break;
            default:
                survives = gcdArr(p.map(Math.abs)) === 1;
        }
        
        const norm = Math.sqrt(p.reduce((s, x) => s + x * x, 0));
        const isBoundary = norm >= S.radius - S.boundaryThickness;
        
        return { point: p, survives, isBoundary, norm };
    });
}

function zeta(s) {
    const vals = { 2: Math.PI**2/6, 3: 1.202, 4: Math.PI**4/90, 5: 1.037, 6: Math.PI**6/945 };
    if (vals[s]) return vals[s];
    let sum = 0;
    for (let n = 1; n < 5000; n++) sum += 1 / Math.pow(n, s);
    return sum;
}

function mainTerm() {
    const R = S.radius, k = S.dimension;
    switch (S.structure) {
        case 'coprime':
        case 'coprime-tuple':
            return Math.pow(R, k) / zeta(k);
        case 'squarefree':
            return R / zeta(2);
        case 'kfree':
            return R / zeta(S.kfreeParam);
        default:
            return Math.pow(R, k) / zeta(k);
    }
}

function errorBound() {
    const R = S.radius, k = S.dimension;
    switch (S.structure) {
        case 'squarefree': return Math.pow(R, 0.5);
        case 'kfree': return Math.pow(R, 1/S.kfreeParam);
        default: return Math.pow(R, k - 1);
    }
}

function computeErrorSeries() {
    S.errorData = [];
    const maxR = S.radius;
    const step = Math.max(1, Math.floor(maxR / 40));
    const origR = S.radius;
    
    for (let r = 5; r <= maxR; r += step) {
        S.radius = r;
        const pts = generatePoints();
        const filt = filterPoints(pts);
        const surv = filt.filter(p => p.survives).length;
        const pred = mainTerm();
        const err = surv - pred;
        const bnd = errorBound();
        
        S.errorData.push({ r, actual: surv, predicted: pred, error: err, bound: bnd });
    }
    
    S.radius = origR;
}

function compute() {
    const status = document.getElementById('statusIndicator');
    const loading = document.getElementById('loadingOverlay');
    status.textContent = 'Computing...';
    status.classList.add('computing');
    loading.classList.add('visible');
    
    const start = performance.now();
    
    requestAnimationFrame(() => {
        setTimeout(() => {
            try {
                S.points = generatePoints();
                S.classified = filterPoints(S.points);
                
                const surviving = S.classified.filter(p => p.survives);
                const boundary = surviving.filter(p => p.isBoundary);
                const pred = mainTerm();
                const actual = surviving.length;
                const err = actual - pred;
                const bnd = errorBound();
                
                document.getElementById('statTotal').textContent = S.points.length.toLocaleString();
                document.getElementById('statSurviving').textContent = actual.toLocaleString();
                document.getElementById('statRemoved').textContent = (S.points.length - actual).toLocaleString();
                document.getElementById('statDensity').textContent = (actual / S.points.length * 100).toFixed(1) + '%';
                document.getElementById('statPredicted').textContent = pred.toFixed(1);
                document.getElementById('statActual').textContent = actual.toLocaleString();
                document.getElementById('statError').textContent = err.toFixed(1);
                document.getElementById('statErrorBound').textContent = bnd.toFixed(1);
                document.getElementById('statRelError').textContent = (Math.abs(err) / pred * 100).toFixed(2) + '%';
                document.getElementById('errorProgress').style.width = Math.min(Math.abs(err) / bnd * 100, 100) + '%';
                document.getElementById('statBoundary').textContent = boundary.length.toLocaleString();
                document.getElementById('statInterior').textContent = (actual - boundary.length).toLocaleString();
                document.getElementById('statExponent').textContent = `${S.dimension-1}/${S.dimension}`;
                
                updateFormulas();
                computeErrorSeries();
                redraw();
                
                const elapsed = (performance.now() - start).toFixed(0);
                document.getElementById('computeTime').textContent = `${elapsed}ms`;
                
            } catch (e) {
                console.error(e);
            }
            
            status.textContent = 'Ready';
            status.classList.remove('computing');
            loading.classList.remove('visible');
        }, 20);
    });
}

function updateFormulas() {
    const k = S.dimension;
    let main, mainEx, err, errEx;
    
    switch (S.structure) {
        case 'coprime':
        case 'coprime-tuple':
            main = `R^${k} / zeta(${k})`;
            mainEx = 'Coprime density';
            err = `O(R^${k-1})`;
            errEx = `${k}D boundary`;
            break;
        case 'squarefree':
            main = '6x / pi^2';
            mainEx = 'Squarefree density';
            err = 'O(x^1/2)';
            errEx = '2D boundary';
            break;
        case 'kfree':
            main = `x / zeta(${S.kfreeParam})`;
            mainEx = `${S.kfreeParam}-free density`;
            err = `O(x^{1/${S.kfreeParam}})`;
            errEx = `${S.kfreeParam}D boundary`;
            break;
        default:
            main = `R^${k} / zeta(${k})`;
            mainEx = 'Expected count';
            err = `O(R^${k-1})`;
            errEx = 'Boundary scaling';
    }
    
    document.getElementById('formulaMain').textContent = main;
    document.getElementById('formulaExplain').textContent = mainEx;
    document.getElementById('errorFormula').textContent = err;
    document.getElementById('errorExplain').textContent = errEx;
}

function project(p, w, h) {
    const k = p.length;
    let x = p[0], y = p[1], z = k > 2 ? p[2] : 0;
    for (let i = 3; i < k; i++) z += p[i] * 0.3;
    
    const rx = S.rotation.x * Math.PI / 180;
    const ry = S.rotation.y * Math.PI / 180;
    
    let y1 = y * Math.cos(rx) - z * Math.sin(rx);
    let z1 = y * Math.sin(rx) + z * Math.cos(rx);
    let x1 = x * Math.cos(ry) + z1 * Math.sin(ry);
    let z2 = -x * Math.sin(ry) + z1 * Math.cos(ry);
    
    const scale = Math.min(w, h) / (S.radius * 2.8);
    const persp = 1 + z2 / (S.radius * 5);
    
    return {
        x: w/2 + x1 * scale * persp,
        y: h/2 - y1 * scale * persp,
        z: z2
    };
}

function drawLattice(canvas, ctx) {
    const w = canvas.width, h = canvas.height;
    ctx.fillStyle = '#0a0a0f';
    ctx.fillRect(0, 0, w, h);
    
    if (document.getElementById('showGrid').checked) drawGrid(ctx, w, h);
    if (document.getElementById('showAxes').checked) drawAxes(ctx, w, h);
    
    const showRem = document.getElementById('showRemoved').checked;
    const showBnd = document.getElementById('showBoundary').checked;
    
    const sorted = [...S.classified].sort((a, b) => project(a.point, w, h).z - project(b.point, w, h).z);
    
    for (const item of sorted) {
        if (!item.survives && !showRem) continue;
        
        const proj = project(item.point, w, h);
        const size = S.pointSize * (0.7 + proj.z / (S.radius * 3) * 0.5);
        
        let color;
        if (!item.survives) color = '#5a2a2a';
        else if (showBnd && item.isBoundary) color = '#c9a227';
        else color = '#5ab87a';
        
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, Math.max(1, size), 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
    }
    
    const surv = S.classified.filter(p => p.survives).length;
    document.getElementById('canvasStats').innerHTML = `Points: ${surv.toLocaleString()}<br>Dim: ${S.dimension}`;
}

function drawBoundary(canvas, ctx) {
    const w = canvas.width, h = canvas.height;
    ctx.fillStyle = '#0a0a0f';
    ctx.fillRect(0, 0, w, h);
    
    if (document.getElementById('showAxes').checked) drawAxes(ctx, w, h);
    
    const scale = Math.min(w, h) / (S.radius * 2.8);
    ctx.strokeStyle = 'rgba(201, 162, 39, 0.25)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(w/2, h/2, S.radius * scale, 0, Math.PI * 2);
    ctx.stroke();
    
    ctx.strokeStyle = 'rgba(201, 162, 39, 0.12)';
    ctx.beginPath();
    ctx.arc(w/2, h/2, (S.radius - S.boundaryThickness) * scale, 0, Math.PI * 2);
    ctx.stroke();
    
    const bndPts = S.classified.filter(p => p.survives && p.isBoundary);
    const sorted = bndPts.sort((a, b) => project(a.point, w, h).z - project(b.point, w, h).z);
    
    for (const item of sorted) {
        const proj = project(item.point, w, h);
        const size = S.pointSize * (0.7 + proj.z / (S.radius * 3) * 0.5);
        
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, Math.max(1, size), 0, Math.PI * 2);
        ctx.fillStyle = '#c9a227';
        ctx.fill();
    }
    
    document.getElementById('canvasStats').innerHTML = `Boundary: ${bndPts.length.toLocaleString()}<br>Shell: ${S.boundaryThickness}`;
}

function drawDensity(canvas, ctx) {
    const w = canvas.width, h = canvas.height;
    ctx.fillStyle = '#0a0a0f';
    ctx.fillRect(0, 0, w, h);
    
    const bins = 40;
    const binW = S.radius / bins;
    const counts = new Array(bins).fill(0);
    const surviving = new Array(bins).fill(0);
    
    for (const item of S.classified) {
        const bin = Math.min(bins - 1, Math.floor(item.norm / binW));
        counts[bin]++;
        if (item.survives) surviving[bin]++;
    }
    
    const densities = counts.map((c, i) => c > 0 ? surviving[i] / c : 0);
    const maxD = Math.max(...densities, 0.01);
    
    const margin = 50;
    const chartW = w - 2 * margin;
    const chartH = h - 2 * margin;
    
    ctx.strokeStyle = '#3a3a4a';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin, margin);
    ctx.lineTo(margin, h - margin);
    ctx.lineTo(w - margin, h - margin);
    ctx.stroke();
    
    const barW = chartW / bins;
    for (let i = 0; i < bins; i++) {
        const barH = (densities[i] / maxD) * chartH * 0.9;
        const isBnd = i >= bins - Math.ceil(S.boundaryThickness / binW);
        
        ctx.fillStyle = isBnd ? '#c9a227' : '#5ab87a';
        ctx.fillRect(margin + i * barW + 1, h - margin - barH, barW - 2, barH);
    }
    
    ctx.fillStyle = '#9898a8';
    ctx.font = '11px JetBrains Mono';
    ctx.textAlign = 'center';
    ctx.fillText('Radius', w/2, h - margin + 25);
    ctx.fillText('0', margin, h - margin + 15);
    ctx.fillText(S.radius.toString(), w - margin, h - margin + 15);
    
    ctx.save();
    ctx.translate(18, h/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('Density', 0, 0);
    ctx.restore();
    
    document.getElementById('canvasStats').innerHTML = `Bins: ${bins}<br>Max: ${maxD.toFixed(3)}`;
}

function drawError(canvas, ctx) {
    const w = canvas.width, h = canvas.height;
    ctx.fillStyle = '#0a0a0f';
    ctx.fillRect(0, 0, w, h);
    
    if (S.errorData.length === 0) {
        ctx.fillStyle = '#9898a8';
        ctx.font = '12px JetBrains Mono';
        ctx.textAlign = 'center';
        ctx.fillText('No error data', w/2, h/2);
        return;
    }
    
    const margin = 55;
    const chartW = w - 2 * margin;
    const chartH = h - 2 * margin;
    
    ctx.strokeStyle = '#3a3a4a';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin, margin);
    ctx.lineTo(margin, h - margin);
    ctx.lineTo(w - margin, h - margin);
    ctx.stroke();
    
    const maxR = Math.max(...S.errorData.map(d => d.r));
    const maxE = Math.max(...S.errorData.map(d => Math.abs(d.error)));
    const maxB = Math.max(...S.errorData.map(d => d.bound));
    const yMax = Math.max(maxE, maxB) * 1.1;
    
    ctx.strokeStyle = '#5ab87a';
    ctx.lineWidth = 2;
    ctx.beginPath();
    S.errorData.forEach((d, i) => {
        const x = margin + (d.r / maxR) * chartW;
        const y = h - margin - (Math.abs(d.error) / yMax) * chartH;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    ctx.strokeStyle = '#c9a227';
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    S.errorData.forEach((d, i) => {
        const x = margin + (d.r / maxR) * chartW;
        const y = h - margin - (d.bound / yMax) * chartH;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.stroke();
    ctx.setLineDash([]);
    
    ctx.fillStyle = '#9898a8';
    ctx.font = '11px JetBrains Mono';
    ctx.textAlign = 'center';
    ctx.fillText('R', w/2, h - margin + 25);
    
    ctx.save();
    ctx.translate(20, h/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('|Error|', 0, 0);
    ctx.restore();
    
    ctx.fillStyle = '#5ab87a';
    ctx.fillRect(w - margin - 70, margin + 10, 10, 10);
    ctx.fillStyle = '#9898a8';
    ctx.textAlign = 'left';
    ctx.fillText('Actual', w - margin - 55, margin + 18);
    
    ctx.fillStyle = '#c9a227';
    ctx.fillRect(w - margin - 70, margin + 26, 10, 10);
    ctx.fillStyle = '#9898a8';
    ctx.fillText('Bound', w - margin - 55, margin + 34);
    
    const last = S.errorData[S.errorData.length - 1];
    document.getElementById('canvasStats').innerHTML = `Err: ${last.error.toFixed(1)}<br>Bnd: ${last.bound.toFixed(1)}`;
}

function drawGrid(ctx, w, h) {
    const scale = Math.min(w, h) / (S.radius * 2.8);
    const step = Math.max(1, Math.floor(S.radius / 8));
    
    ctx.strokeStyle = '#1a1a28';
    ctx.lineWidth = 0.5;
    
    for (let i = -S.radius; i <= S.radius; i += step) {
        const p1 = project([i, -S.radius, 0], w, h);
        const p2 = project([i, S.radius, 0], w, h);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        
        const p3 = project([-S.radius, i, 0], w, h);
        const p4 = project([S.radius, i, 0], w, h);
        ctx.beginPath();
        ctx.moveTo(p3.x, p3.y);
        ctx.lineTo(p4.x, p4.y);
        ctx.stroke();
    }
}

function drawAxes(ctx, w, h) {
    const len = S.radius * 0.85;
    const o = project([0, 0, 0], w, h);
    const xEnd = project([len, 0, 0], w, h);
    const yEnd = project([0, len, 0], w, h);
    const zEnd = project([0, 0, len], w, h);
    
    ctx.lineWidth = 1.5;
    
    ctx.strokeStyle = '#b85a5a';
    ctx.beginPath();
    ctx.moveTo(o.x, o.y);
    ctx.lineTo(xEnd.x, xEnd.y);
    ctx.stroke();
    
    ctx.strokeStyle = '#5ab85a';
    ctx.beginPath();
    ctx.moveTo(o.x, o.y);
    ctx.lineTo(yEnd.x, yEnd.y);
    ctx.stroke();
    
    if (S.dimension > 2) {
        ctx.strokeStyle = '#5a5ab8';
        ctx.beginPath();
        ctx.moveTo(o.x, o.y);
        ctx.lineTo(zEnd.x, zEnd.y);
        ctx.stroke();
    }
    
    ctx.font = '10px JetBrains Mono';
    ctx.fillStyle = '#b85a5a';
    ctx.fillText('x', xEnd.x + 4, xEnd.y);
    ctx.fillStyle = '#5ab85a';
    ctx.fillText('y', yEnd.x + 4, yEnd.y);
    if (S.dimension > 2) {
        ctx.fillStyle = '#5a5ab8';
        ctx.fillText('z', zEnd.x + 4, zEnd.y);
    }
}

function redraw() {
    const canvas = document.getElementById('mainCanvas');
    const wrapper = document.getElementById('canvasWrapper');
    const rect = wrapper.getBoundingClientRect();
    const size = Math.min(rect.width, rect.height);
    
    const dpr = window.devicePixelRatio || 1;
    canvas.width = size * dpr;
    canvas.height = size * dpr;
    canvas.style.width = size + 'px';
    canvas.style.height = size + 'px';
    
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    
    const labels = { lattice: 'Lattice Structure', boundary: 'Boundary Shell', density: 'Radial Density', error: 'Error Analysis' };
    document.getElementById('canvasLabel').textContent = labels[S.currentView];
    
    switch (S.currentView) {
        case 'lattice': drawLattice(canvas, ctx); break;
        case 'boundary': drawBoundary(canvas, ctx); break;
        case 'density': drawDensity(canvas, ctx); break;
        case 'error': drawError(canvas, ctx); break;
    }
}

function setView(view) {
    S.currentView = view;
    document.querySelectorAll('.view-tab').forEach(t => t.classList.toggle('active', t.dataset.view === view));
    redraw();
}

function setDimension(k) {
    k = parseInt(k);
    if (k < 2 || k > 6) return;
    
    S.dimension = k;
    document.querySelectorAll('.dim-btn').forEach(b => b.classList.toggle('active', parseInt(b.dataset.dim) === k));
    document.getElementById('statDimension').textContent = k;
    
    if (k >= 4 && S.radius > 40) {
        S.radius = 25;
        document.getElementById('radius').value = 25;
        document.getElementById('radiusValue').textContent = '25';
        document.getElementById('statRadius').textContent = '25';
    }
    
    compute();
}

function updateRadius() {
    const v = parseInt(document.getElementById('radius').value);
    S.radius = v;
    document.getElementById('radiusValue').textContent = v;
    document.getElementById('statRadius').textContent = v;
}

function updateKfree() {
    const v = parseInt(document.getElementById('kfree').value);
    S.kfreeParam = v;
    document.getElementById('kfreeValue').textContent = v;
}

function updatePointSize() {
    const v = parseInt(document.getElementById('pointSize').value);
    S.pointSize = v;
    document.getElementById('pointSizeValue').textContent = v;
    redraw();
}

function updateBoundaryThick() {
    const v = parseInt(document.getElementById('boundaryThick').value);
    S.boundaryThickness = v;
    document.getElementById('boundaryThickValue').textContent = v;
    redraw();
}

function updateRotation() {
    S.rotation.x = parseInt(document.getElementById('rotX').value);
    S.rotation.y = parseInt(document.getElementById('rotY').value);
    document.getElementById('rotXValue').textContent = S.rotation.x;
    document.getElementById('rotYValue').textContent = S.rotation.y;
    redraw();
}

function resetRotation() {
    S.rotation = { x: 25, y: 35 };
    document.getElementById('rotX').value = 25;
    document.getElementById('rotY').value = 35;
    updateRotation();
}

let animId = null;
function toggleAnimation() {
    S.animating = !S.animating;
    document.getElementById('animateBtn').textContent = S.animating ? 'Stop' : 'Animate';
    
    if (S.animating) {
        const animate = () => {
            if (!S.animating) return;
            S.rotation.y = (S.rotation.y + 0.8) % 360;
            document.getElementById('rotY').value = S.rotation.y;
            document.getElementById('rotYValue').textContent = Math.round(S.rotation.y);
            redraw();
            animId = requestAnimationFrame(animate);
        };
        animate();
    } else if (animId) {
        cancelAnimationFrame(animId);
    }
}

function updateStructure() {
    const type = document.getElementById('structureType').value;
    S.structure = type;
    
    const names = {
        'coprime': 'Coprime Lattice',
        'squarefree': 'Squarefree',
        'kfree': 'k-Free',
        'coprime-tuple': 'Coprime Tuples',
        'prime-ktuple': 'Prime k-Tuple',
        'custom': 'Custom Tuple'
    };
    document.getElementById('statStructure').textContent = names[type];
    
    document.getElementById('kfreeParam').style.display = type === 'kfree' ? 'block' : 'none';
    document.getElementById('tupleSection').style.display = (type === 'prime-ktuple' || type === 'custom') ? 'block' : 'none';
}

function exportPNG(type) {
    const exp = document.getElementById('exportCanvas');
    exp.width = 3840;
    exp.height = 3840;
    const ctx = exp.getContext('2d');
    
    const origView = S.currentView;
    
    if (type === 'all') {
        const views = ['lattice', 'boundary', 'density', 'error'];
        const positions = [[0, 0], [1920, 0], [0, 1920], [1920, 1920]];
        
        const temp = document.createElement('canvas');
        temp.width = 1920;
        temp.height = 1920;
        const tCtx = temp.getContext('2d');
        
        views.forEach((v, i) => {
            S.currentView = v;
            switch (v) {
                case 'lattice': drawLattice(temp, tCtx); break;
                case 'boundary': drawBoundary(temp, tCtx); break;
                case 'density': drawDensity(temp, tCtx); break;
                case 'error': drawError(temp, tCtx); break;
            }
            ctx.drawImage(temp, positions[i][0], positions[i][1]);
        });
        
        S.currentView = origView;
    } else {
        switch (S.currentView) {
            case 'lattice': drawLattice(exp, ctx); break;
            case 'boundary': drawBoundary(exp, ctx); break;
            case 'density': drawDensity(exp, ctx); break;
            case 'error': drawError(exp, ctx); break;
        }
    }
    
    ctx.fillStyle = '#9898a8';
    ctx.font = '28px JetBrains Mono';
    ctx.fillText(`BCP - ${S.structure} - k=${S.dimension} - R=${S.radius}`, 20, 50);
    
    const link = document.createElement('a');
    link.download = `bcp-${type}-${Date.now()}.png`;
    link.href = exp.toDataURL('image/png');
    link.click();
}

function exportCSV(type) {
    let csv = '', filename = '';
    
    switch (type) {
        case 'points':
            csv = 'idx,' + Array.from({length: S.dimension}, (_, i) => `x${i+1}`).join(',') + ',survives,boundary,norm\n';
            S.classified.forEach((item, i) => {
                csv += `${i},${item.point.join(',')},${item.survives?1:0},${item.isBoundary?1:0},${item.norm.toFixed(4)}\n`;
            });
            filename = 'lattice-points';
            break;
            
        case 'stats':
            csv = 'metric,value\n';
            csv += `structure,${S.structure}\n`;
            csv += `dimension,${S.dimension}\n`;
            csv += `radius,${S.radius}\n`;
            csv += `total,${S.points.length}\n`;
            csv += `surviving,${S.classified.filter(p=>p.survives).length}\n`;
            csv += `boundary,${S.classified.filter(p=>p.survives&&p.isBoundary).length}\n`;
            csv += `predicted,${mainTerm()}\n`;
            csv += `error,${S.classified.filter(p=>p.survives).length - mainTerm()}\n`;
            csv += `error_bound,${errorBound()}\n`;
            csv += `critical_exponent,${(S.dimension-1)/S.dimension}\n`;
            filename = 'statistics';
            break;
            
        case 'error':
            csv = 'radius,actual,predicted,error,bound\n';
            S.errorData.forEach(d => {
                csv += `${d.r},${d.actual},${d.predicted.toFixed(4)},${d.error.toFixed(4)},${d.bound.toFixed(4)}\n`;
            });
            filename = 'error-analysis';
            break;
            
        case 'all':
            exportCSV('points');
            exportCSV('stats');
            exportCSV('error');
            return;
    }
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const link = document.createElement('a');
    link.download = `${filename}-${Date.now()}.csv`;
    link.href = URL.createObjectURL(blob);
    link.click();
}

function showHelp() { document.getElementById('helpModal').classList.add('visible'); }
function hideHelp() { document.getElementById('helpModal').classList.remove('visible'); }

window.addEventListener('resize', () => setTimeout(redraw, 50));

document.getElementById('helpModal').addEventListener('click', e => {
    if (e.target === document.getElementById('helpModal')) hideHelp();
});

document.addEventListener('DOMContentLoaded', () => {
    updateStructure();
    compute();
});
</script>

</body>
    </html>
