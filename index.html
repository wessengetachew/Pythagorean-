
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Pythagorean GCD Explorer: Modular Dashboard</title>
    
    <style>
        /* BASE & THEME */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #0b0c10; /* Very Dark Background */
            color: #c5c5c5; /* Light Text */
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }
        
        /* HEADER/TITLE BAR (Prominent) */
        header {
            width: 100%;
            background-color: #1a1a2e; /* Dark Blue/Purple Header */
            color: #7ef9f9; /* Neon Blue/Cyan Title */
            padding: 15px 0;
            text-align: center;
            margin-bottom: 20px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            border-bottom: 2px solid #582f9d; /* Accent Line */
        }
        header h1 {
            margin: 0;
            font-size: 1.8em;
            letter-spacing: 1px;
        }
        header p {
            margin: 5px 0 0;
            font-size: 0.9em;
            color: #a0a0a0;
        }

        /* MAIN CONTAINER (The Dashboard Frame) */
        .container {
            display: flex;
            width: 95%;
            max-width: 1500px;
            background: #1f1f2e; /* Slightly lighter main dashboard body */
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            min-height: 80vh;
            overflow: hidden; 
        }

        /* CONTROL PANEL (Sidebar) */
        .controls {
            flex: 1;
            padding: 25px;
            border-right: 1px solid #33334d; 
            max-width: 350px;
            background-color: #1a1a2e; 
            overflow-y: auto;
        }

        /* CANVAS AREA (Main Grid) */
        .canvas-container {
            flex: 3;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            align-content: flex-start; 
            padding: 20px 10px;
            background-color: #1f1f2e;
        }
        
        /* INDIVIDUAL CANVAS VIEW */
        .canvas-view {
            width: 30%; 
            min-width: 380px;
            margin: 10px;
            text-align: center;
        }
        
        /* CANVAS STYLING */
        canvas {
            border: 1px solid #582f9d; 
            background-color: #0d0d1a; 
            width: 100%;
            height: auto;
        }
        .canvas-view h3 {
             color: #7ef9f9;
             margin-top: 5px;
             font-size: 1em;
        }

        /* CONTROL ELEMENTS */
        section {
            margin-bottom: 25px;
            padding: 10px;
            border: 1px solid #33334d;
            border-radius: 4px;
        }
        label, button, input, select {
            display: block;
            margin-top: 8px;
            color: #d4d4d4;
            background-color: #2a2a44; 
            border: 1px solid #582f9d;
            padding: 7px;
            width: 95%;
            box-sizing: border-box;
        }
        button {
            background-color: #582f9d; 
            cursor: pointer;
            border: none;
            padding: 10px;
            width: 100%;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #7c4fd7;
        }
        
        /* ANALYSIS TEXT */
        #results p, .analysis-detail p {
            margin: 5px 0;
            font-weight: bold;
            color: #4ec9b0; 
        }
        .analysis-detail {
            font-size: 0.9em;
            margin-top: 10px;
            background-color: #2a2a44;
            padding: 10px;
            border-radius: 3px;
        }
        .export-section button {
            margin-bottom: 5px;
        }
    </style>
</head>
<body>

    <header>
        <h1>ULTIMATE MODULAR EXPLORER: PYTHAGOREAN DIAGONALS</h1>
        <p>A Unified Dashboard for GCD Geometry, Gaussian Primes, and Modular Lifting.</p>
    </header>

    <div class="container">
        <aside class="controls">
            <h2>‚öôÔ∏è System Controls</h2>
            
            <section class="input-section">
                <h3>1. Diagonal Definition ($a^2 + b^2 = c^2$)</h3>
                <label for="inputA">Side $a$ (Integer):</label>
                <input type="number" id="inputA" value="3" min="1">
                <label for="inputB">Side $b$ (Integer):</label>
                <input type="number" id="inputB" value="4" min="1">
                <button onclick="calculateAndDraw()">ANALYZE & DRAW ALL VIEWS</button>
                
                <div id="results">
                    <p>Diagonal $c$: <span id="valC">5.000</span></p>
                    <p>Modulus $M$: <span id="valM">5</span></p>
                    <p>Fermat $\pmod{4}$ Test: <span id="fermat-test">1</span></p>
                    <p>Gaussian Prime? $\pi=a+bi$: <span id="is-gaussian-prime">Yes</span></p>
                </div>
                <button onclick="runPrimeSieve()">SIEVE: Prime Distribution Check</button>
            </section>
            
            <hr>

            <section class="analysis-section">
                <h3>2. Modular Analysis & Channels</h3>
                <p>Totient $\varphi(M)$: <span id="valPhi">4</span></p>
                <p>Coprime Density $\varphi(M)/M$: <span id="valDensity">0.800</span></p>
                <p>Active Channels (Character Support): <span id="valActiveChannels">4</span></p>
                
                <label for="gap-g">Gap Analysis $g$ (e.g., Twin Primes):</label>
                <input type="number" id="gap-g" value="2" min="1">
                
                <div class="analysis-detail">
                    <label for="residue-r">Select Residue $r \in [1, M-1]$:</label>
                    <input type="number" id="residue-r" value="1" min="1">
                    <button onclick="analyzeResidue()">ANALYZE RESIDUE $r$</button>
                    <p>GCD $\text{gcd}(r, M)$: <span id="val-gcd">1</span></p>
                    <p>Element Order $\text{ord}_M(r)$: <span id="val-order">4</span></p>
                </div>
            </section>
            
            <hr>

            <section class="visual-section">
                <h3>3. Geometry & Lifting Controls</h3>
                
                <label for="coord-system">Canvas 1 Coordinate System:</label>
                <select id="coord-system">
                    <option value="polar">Polar/Unit Circle (Default)</option>
                    <option value="log-cylinder">Log-Cylinder ($\theta$ vs. $\log(r)$)</option>
                    <option value="smith">Smith Chart (Cayley Map)</option>
                </select>
                
                <label for="num-lifts">Number of $M \to 2M$ Dyadic Lifts:</label>
                <input type="number" id="num-lifts" value="3" min="1">
                <button onclick="drawLiftingRings()">REDRAW LIFTS & GAPS</button>
                
                <label for="lift-type">Lift Connection Style:</label>
                <select id="lift-type">
                    <option value="dyadic">Dyadic Lift ($r \to r+M$)</option>
                    <option value="direct">Direct Lift ($r \to r$)</option>
                </select>
            </section>
            
            <hr>

            <section class="export-section">
                <h3>4. Export & Report Generation üíæ</h3>
                
                <label for="export-resolution">Canvas Resolution for Export:</label>
                <select id="export-resolution">
                    <option value="1000">1K (1000x1000)</option>
                    <option value="2000">2K (2000x2000)</option>
                    <option value="4000">4K (4000x4000)</option>
                </select>
                <button onclick="exportCanvases()">Export All Canvases (PNG)</button>
                
                <button onclick="exportCSV()">Export GCD Data Table (CSV)</button>
                
                <button onclick="generatePDF()">Generate Full Report (PDF)</button>
                
                <hr style="border-top: 1px solid #7c4fd7;">
                <button onclick="generateShareLink()">Generate Shareable Link</button>
                <p style="font-size: 0.8em; color: #4ec9b0; word-wrap: break-word;">Share URL: <span id="share-link-output">...</span></p>

            </section>

        </aside>

        <div class="canvas-container">
            
            <div class="canvas-view">
                <h3>1. GCD Geometry ($\mathbb{Z}/M\mathbb{Z}$) & Channels</h3>
                <canvas id="canvasGCD" width="450" height="450"></canvas>
            </div>
            
            <div class="canvas-view">
                <h3>2. Gaussian Prime $\pi=a+bi$ (Diagonal $c$)</h3>
                <canvas id="canvasGaussian" width="450" height="450"></canvas>
            </div>
            
            <div class="canvas-view">
                <h3>3. Modular Dyadic Lifting & Gap ($g$)</h3>
                <canvas id="canvasGap" width="450" height="450"></canvas>
            </div>
            
        </div>
    </div>

    <script>
        // --- CORE MATHEMATICAL FUNCTIONS ---
        function gcd(a, b) { while (b) { [a, b] = [b, a % b]; } return a; }

        function phi(n) {
            let count = 0;
            for (let r = 1; r < n; r++) { if (gcd(r, n) === 1) { count++; } }
            return count;
        }

        function isPrime(n) {
            if (n <= 1) return false;
            for (let i = 2; i * i <= n; i++) { if (n % i === 0) return false; }
            return true;
        }

        function elementOrder(r, m) {
            if (gcd(r, m) !== 1) return "N/A";
            let k = 1;
            let current = r % m;
            while (current !== 1) {
                current = (current * r) % m;
                k++;
            }
            return k;
        }

        // --- GLOBAL VARIABLES & CANVAS SETUP ---
        let currentM = 0;
        let currentA = 3; 
        let currentB = 4;
        const canvasGCD = document.getElementById('canvasGCD');
        const ctxGCD = canvasGCD.getContext('2d');
        const canvasGaussian = document.getElementById('canvasGaussian');
        const ctxGaussian = canvasGaussian.getContext('2d');
        const canvasGap = document.getElementById('canvasGap');
        const ctxGap = canvasGap.getContext('2d');
        
        // --- DRAWING UTILITIES ---
        function drawPoint(ctx, x, y, size, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, 2 * Math.PI);
            ctx.fill();
        }

        // --- CANVAS 1: GCD GEOMETRY ---
        // Refactored to accept context and size for high-res export
        function drawGCDGeometry(M, coordSystem, ctx, width, height) {
            ctx.clearRect(0, 0, width, height);
            const center = width / 2;
            const radius = center * 0.8;
            
            ctx.fillStyle = '#0d0d1a'; // Canvas background
            ctx.fillRect(0, 0, width, height);

            ctx.strokeStyle = '#4e4e4e';
            ctx.beginPath();
            ctx.arc(center, center, radius, 0, 2 * Math.PI);
            ctx.stroke();

            for (let r = 1; r < M; r++) {
                const angle = (2 * Math.PI * r) / M;
                const x = center + radius * Math.cos(angle - Math.PI / 2);
                const y = center + radius * Math.sin(angle - Math.PI / 2);
                
                const gcdVal = gcd(r, M);
                const isOpen = (gcdVal === 1);
                const pointSize = isOpen ? 5 * (width/450) : 3 * (width/450); // Scale size
                
                const color = isOpen ? '#00cc66' : '#cc0000'; 
                
                ctx.strokeStyle = isOpen ? 'rgba(0, 204, 102, 0.5)' : 'rgba(204, 0, 0, 0.2)';
                ctx.lineWidth = 1.5 * (width/450);
                ctx.beginPath();
                ctx.moveTo(center, center);
                ctx.lineTo(x, y);
                ctx.stroke();

                drawPoint(ctx, x, y, pointSize, color);
            }
             ctx.fillStyle = '#d4d4d4';
             ctx.font = `${14 * (width/450)}px Arial`;
             ctx.fillText(`System: ${coordSystem}`, 10 * (width/450), 20 * (width/450));
        }

        // --- CANVAS 2: GAUSSIAN INTEGERS ---
        function drawGaussian(a, b, M, ctx, width, height) {
            ctx.clearRect(0, 0, width, height);
            const center = width / 2;
            const maxVal = Math.max(a, b, 2);
            const scale = center * 0.9 / maxVal; 

            ctx.fillStyle = '#0d0d1a'; 
            ctx.fillRect(0, 0, width, height);
            
            ctx.strokeStyle = '#555';
            ctx.beginPath(); ctx.moveTo(0, center); ctx.lineTo(width, center); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(center, 0); ctx.lineTo(center, height); ctx.stroke();

            const x = center + a * scale;
            const y = center - b * scale; 
            const pointSize = 7 * (width/450);

            drawPoint(ctx, x, y, pointSize, '#ffc600'); 
            
            ctx.strokeStyle = '#ffc600';
            ctx.lineWidth = 2 * (width/450);
            ctx.beginPath();
            ctx.moveTo(center, center);
            ctx.lineTo(x, y);
            ctx.stroke();

            const angleRad = Math.atan2(b, a);
            const angleDeg = (angleRad * 180 / Math.PI).toFixed(1);
            ctx.fillStyle = '#ffc600';
            ctx.font = `${14 * (width/450)}px Arial`;
            ctx.fillText(`Angle: ${angleDeg}¬∞`, center + 10 * (width/450), center + 20 * (width/450));
        }

        // --- CANVAS 3: MODULAR LIFTING & GAP ANALYSIS ---
        function drawLiftingRings(M, numLifts, liftType, gapG, ctx, width, height) {
            ctx.clearRect(0, 0, width, height);
            const center = width / 2;
            const maxRadius = center * 0.9;
            const ringSpacing = maxRadius / (numLifts + 1);

            ctx.fillStyle = '#0d0d1a'; 
            ctx.fillRect(0, 0, width, height);

            for (let i = 0; i <= numLifts; i++) {
                const ringM = M * Math.pow(2, i); 
                const radius = ringSpacing * (i + 1);
                
                ctx.strokeStyle = 'rgba(100, 100, 255, 0.5)';
                ctx.lineWidth = 1 * (width/450);
                ctx.beginPath();
                ctx.arc(center, center, radius, 0, 2 * Math.PI);
                ctx.stroke();
                
                for (let r = 1; r < ringM; r++) {
                    if (gcd(r, ringM) === 1) { 
                        const angle = (2 * Math.PI * r) / ringM;
                        const x = center + radius * Math.cos(angle - Math.PI / 2);
                        const y = center + radius * Math.sin(angle - Math.PI / 2);
                        
                        const r_g = r + gapG;
                        const hasGap = (r_g < ringM) && (gcd(r_g, ringM) === 1);
                        const pointSize = hasGap ? 4 * (width/450) : 3 * (width/450);
                        
                        drawPoint(ctx, x, y, pointSize, hasGap ? '#4ec9b0' : '#8c8c8c');

                        if (hasGap) {
                             const angle_g = (2 * Math.PI * r_g) / ringM;
                             const x_g = center + radius * Math.cos(angle_g - Math.PI / 2);
                             const y_g = center + radius * Math.sin(angle_g - Math.PI / 2);
                             
                             ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)'; 
                             ctx.lineWidth = 1 * (width/450);
                             ctx.beginPath();
                             ctx.moveTo(x, y);
                             ctx.lineTo(x_g, y_g);
                             ctx.stroke();
                        }
                    }
                }
            }
        }
        
        // --- HIGH-LEVEL DRAWING CALLS ---

        function calculateAndDraw() {
            currentA = parseInt(document.getElementById('inputA').value) || 0;
            currentB = parseInt(document.getElementById('inputB').value) || 0;
            
            if (currentA === 0 || currentB === 0) return;

            const c_squared = currentA * currentA + currentB * currentB;
            const c_real = Math.sqrt(c_squared);
            const M = Math.round(c_real); 

            currentM = M;

            // 1. Analysis Stats
            const phiM = phi(M);
            const isPrimeM = isPrime(M);
            const fermatTest = M % 4; 
            const density = (phiM / M).toFixed(3);
            const isGaussianPrime = isPrimeM && (fermatTest === 1 || M === 2);

            document.getElementById('valC').textContent = c_real.toFixed(3);
            document.getElementById('valM').textContent = M;
            document.getElementById('valPhi').textContent = phiM;
            document.getElementById('valDensity').textContent = density;
            document.getElementById('valActiveChannels').textContent = phiM;
            document.getElementById('fermat-test').textContent = `${fermatTest} (${isPrimeM ? (fermatTest === 1 ? 'Splits' : 'Inert') : 'Composite'})`;
            document.getElementById('is-gaussian-prime').textContent = isGaussianPrime ? "Yes (Splits)" : "No (Inert/Comp)";

            // 2. Draw Canvases on screen
            const coordSystem = document.getElementById('coord-system').value;
            const numLifts = parseInt(document.getElementById('num-lifts').value);
            const liftType = document.getElementById('lift-type').value;
            const gapG = parseInt(document.getElementById('gap-g').value);

            drawGCDGeometry(M, coordSystem, ctxGCD, canvasGCD.width, canvasGCD.height);
            drawGaussian(currentA, currentB, M, ctxGaussian, canvasGaussian.width, canvasGaussian.height);
            drawLiftingRings(M, numLifts, liftType, gapG, ctxGap, canvasGap.width, canvasGap.height);
            
            document.getElementById('residue-r').value = 1;
            analyzeResidue();
        }

        function analyzeResidue() {
            const r = parseInt(document.getElementById('residue-r').value);
            const M = currentM;
            if (r >= M || r < 1 || M === 0) return;
            
            const g = gcd(r, M);
            document.getElementById('val-gcd').textContent = `${g} (Status: ${g === 1 ? 'Open' : 'Pruned'})`;
            document.getElementById('val-order').textContent = elementOrder(r, M);
        }

        function runPrimeSieve() {
             const M = currentM;
             if (M === 0) return;
             alert(`Sieve running up to ${M}... (Functionality to highlight prime residues would be implemented here)`);
        }
        
        function drawLiftingRings() {
            const numLifts = parseInt(document.getElementById('num-lifts').value);
            const liftType = document.getElementById('lift-type').value;
            const gapG = parseInt(document.getElementById('gap-g').value);
            drawLiftingRings(currentM, numLifts, liftType, gapG, ctxGap, canvasGap.width, canvasGap.height);
        }


        // --- EXPORT & SHARING FUNCTIONS ---

        function generateShareLink() {
            const a = document.getElementById('inputA').value;
            const b = document.getElementById('inputB').value;
            const r = document.getElementById('residue-r').value;
            const g = document.getElementById('gap-g').value;
            const lifts = document.getElementById('num-lifts').value;
            const coords = document.getElementById('coord-system').value;
            
            const params = new URLSearchParams();
            params.append('a', a);
            params.append('b', b);
            params.append('r', r);
            params.append('g', g);
            params.append('lifts', lifts);
            params.append('coords', coords);
            
            const shareURL = window.location.origin + window.location.pathname + '?' + params.toString();
            
            document.getElementById('share-link-output').textContent = shareURL;
            navigator.clipboard.writeText(shareURL).then(() => {
                alert("Shareable link copied to clipboard!");
            });
            return shareURL;
        }

        function loadParametersFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            if (params.has('a')) document.getElementById('inputA').value = params.get('a');
            if (params.has('b')) document.getElementById('inputB').value = params.get('b');
            if (params.has('r')) document.getElementById('residue-r').value = params.get('r');
            if (params.has('g')) document.getElementById('gap-g').value = params.get('g');
            if (params.has('lifts')) document.getElementById('num-lifts').value = params.get('lifts');
            if (params.has('coords')) document.getElementById('coord-system').value = params.get('coords');
            
            if (params.toString().length > 0) {
                calculateAndDraw();
            }
        }

        /**
         * Renders a canvas at a target resolution and triggers a download.
         */
        function exportSingleCanvas(canvasId, fileName) {
            const resolution = parseInt(document.getElementById('export-resolution').value);
            const M = currentM;
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = resolution;
            tempCanvas.height = resolution;
            const tempCtx = tempCanvas.getContext('2d');
            
            const coordSystem = document.getElementById('coord-system').value;
            const numLifts = parseInt(document.getElementById('num-lifts').value);
            const liftType = document.getElementById('lift-type').value;
            const gapG = parseInt(document.getElementById('gap-g').value);

            // Redraw the scene at the new high resolution
            if (canvasId === 'canvasGCD') {
                drawGCDGeometry(M, coordSystem, tempCtx, resolution, resolution);
            } else if (canvasId === 'canvasGaussian') {
                drawGaussian(currentA, currentB, M, tempCtx, resolution, resolution);
            } else if (canvasId === 'canvasGap') {
                drawLiftingRings(M, numLifts, liftType, gapG, tempCtx, resolution, resolution);
            }

            // Trigger Download
            tempCanvas.toBlob(function(blob) {
                const link = document.createElement('a');
                link.download = `${fileName}_M${M}_${resolution}x${resolution}.png`;
                link.href = URL.createObjectURL(blob);
                link.click();
            }, 'image/png');
        }

        function exportCanvases() {
            if (currentM === 0) return alert("Please set a valid diagonal (a, b) first.");

            exportSingleCanvas('canvasGCD', 'GCD_Geometry');
            exportSingleCanvas('canvasGaussian', 'Gaussian_Prime');
            exportSingleCanvas('canvasGap', 'Modular_Lifting');
        }

        function exportCSV() {
            const M = currentM;
            if (M === 0) return alert("Please set a valid modulus M first.");

            let csv = "Residue r,GCD(r,M),Status,Angle (Degrees),Element Order\n";
            
            for (let r = 1; r < M; r++) {
                const g = gcd(r, M);
                const status = g === 1 ? 'Open (Character Support)' : 'Pruned (Zero Divisor)';
                const angleDeg = (360 * r / M).toFixed(4);
                const order = elementOrder(r, M); 
                
                csv += `${r},${g},"${status}",${angleDeg},${order}\n`;
            }

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `GCD_Analysis_M${M}_Full_Report.csv`;
            link.click();
            alert(`Exported GCD Analysis for M=${M} to CSV.`);
        }

        function generatePDF() {
            alert("This function requires an external PDF library (like jsPDF) to generate a professional multi-page report, including all canvases and data tables.");
        }


        // --- INITIALIZATION ---
        
        document.getElementById('coord-system').addEventListener('change', () => calculateAndDraw());
        document.getElementById('num-lifts').addEventListener('change', drawLiftingRings);
        document.getElementById('gap-g').addEventListener('change', drawLiftingRings);
        document.getElementById('lift-type').addEventListener('change', drawLiftingRings);
        document.getElementById('inputA').addEventListener('change', calculateAndDraw);
        document.getElementById('inputB').addEventListener('change', calculateAndDraw);


        document.addEventListener('DOMContentLoaded', () => {
             loadParametersFromURL();
             if (currentM === 0) { // If no URL params loaded, run default
                calculateAndDraw();
             }
        });
    </script>
</body>
</html>
